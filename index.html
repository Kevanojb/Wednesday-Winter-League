<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Wednesday Winter League — League & Eclectic</title>
    <link rel="icon" href="./favicon.ico" />
    <meta name="theme-color" content="#199f57" />
    <meta property="og:title" content="Wednesday Winter League — League & Eclectic" />
    <meta property="og:description" content="Event results, ratings, standings, player hole analysis and eclectic leaderboard." />

    <!-- Tailwind Config FIRST -->
    <script>
      window.tailwind = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              squab: {
                50:  '#eefbf2',
                100: '#d8f5e3',
                200: '#b4eac9',
                300: '#86dbab',
                400: '#55c787',
                500: '#2fb66a',
                600: '#199f57',
                700: '#147f47',
                800: '#12663b',
                900: '#0f5232'
              }
            }
          }
        }
      };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React + Babel + Supabase (UMD builds) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

    <!-- Base styles -->
    <style>
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      .chip {
        padding: 0.3rem 0.65rem;
        border-radius: 0.5rem;
        border: 1px solid #c6e7d0;
        background: #eefbf2;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background 0.15s, transform 0.15s;
      }
      .chip:hover {
        background: #dff7e6;
        transform: translateY(-1px);
      }
      .btn {
        padding: 0.5rem 0.75rem;
        border-radius: 0.75rem;
        transition: all 0.15s ease;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      }
      .panel-mint {
        background: #eefbf2;
        border: 1px solid #b4eac9;
      }
      @media print { .hide-print { display: none !important; } }
    </style>
  </head>

  <body class="bg-neutral-50 text-neutral-900">
    <div id="root"></div>

    <!-- React App -->
    <script type="text/babel" data-presets="react">
      /* global React, ReactDOM, supabase */

      const { useState, useEffect, useMemo, useRef } = React;

      // -----------------------
      // Utility Functions
      // -----------------------

      const POINTS_TABLE = [20,17,15,13,11,9,8,7,6,5,4,3,2,1];
      const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

      const to1 = x => Math.round((Number(x)||0)*10)/10;

      function toast(msg){
        try{
          const t=document.createElement('div');
          t.className='fixed bottom-4 right-4 left-4 md:left-auto md:right-4 px-3 py-2 rounded-lg bg-black text-white text-sm shadow z-50 text-center';
          t.textContent=msg;
          document.body.appendChild(t);
          setTimeout(()=>{
            t.style.opacity='0';
            t.style.transition='opacity .2s';
            setTimeout(()=>t.remove(),220);
          }, 1400);
        }catch{}
      }

      // -----------------------
      // Default / fallback course data
      // -----------------------

      const COURSE_DEFAULT_MEN = [4,4,3,4,5,4,3,4,4, 4,5,4,3,4,4,5,3,4];
      const COURSE_DEFAULT_WOMEN = [4,4,3,4,5,4,3,4,4, 4,4,5,3,4,4,5,3,4];

      const COURSE_YARDS_MEN = [
        564,443,166,402,487,300,185,404,353,
        407,159,529,416,375,409,505,136,413
      ];
      const COURSE_YARDS_WOMEN = [
        498,364,111,329,420,230,147,358,276,
        391,127,412,347,305,363,402,78,345
      ];

      const COURSE_STROKE_INDEX = [
        10,6,16,4,18,12,14,2,8,
        5,11,17,1,7,3,13,15,9
      ];

      // -----------------------
      // Handicap Maths
      // -----------------------

      function playingCapByGender(g){ return g==="F"?36:28; }
      function rangeForHcap(h){
        if(h<=9)return"0-9";
        if(h<=18)return"10-18";
        if(h<=28)return"19-28";
        return"29-36";
      }
      function cutPerPointOver34(h){
        const r=rangeForHcap(h);
        return r==="0-9"?0.5 : r==="10-18"?1 : r==="19-28"?1 : 1.5;
      }
      function winnerBonusCut(h){
        const r=rangeForHcap(h);
        return r==="0-9"?1 : r==="10-18"?2 : r==="19-28"?2.5 : 3;
      }
      function computeNewExactHandicap(start,g,pts,b9,isWinner){
        const startPlay=Math.round(start);
        let exact=start;

        if(pts>=35){
          exact-=cutPerPointOver34(startPlay)*(pts-34);
        } else if(pts<=31){
          exact+=0.5*(32-pts);
        }

        if(isWinner) exact-=winnerBonusCut(startPlay);

        const max=playingCapByGender(g);
        const bounded=clamp(exact,0,60);
        const nextPlay=clamp(Math.round(bounded),0,max);

        return {
          nextExact:bounded,
          nextPlaying:nextPlay
        };
      }

      // -----------------------
      // CSV Parsing helpers
      // -----------------------

      const isTeamLike = name => {
        const s = (name || '').trim();
        return (
          /^players?$/i.test(s) ||
          /^team(\s*\d+)?$/i.test(s) ||
          /^team average$/i.test(s) ||
          /^stableford$/i.test(s) ||
          /^strokeplay$/i.test(s) ||
          /^round\s*\d+$/i.test(s) ||
          /^(out|in|total|s\.i\.|par)$/i.test(s)
        );
      };

      function splitSmart(raw){
        const d = raw.includes('\t') ? '\t' : (raw.includes(';') ? ';' : ',');
        return raw.split(d).map(s => (s||'').replace(/^"|"$/g,'').trim());
      }
      function toNum(x){
        const v=parseFloat(String(x == null ? '' : x).replace(/[^0-9.\-]/g,''));
        return Number.isFinite(v)?v:NaN;
      }

      // Read per-hole Stableford for an individual card
      function readStablefordPerHole(row){
        let start=-1;
        for(let i=0;i<row.length;i++){
          if(String(row[i]).trim().toLowerCase()==='stableford'){ start=i; break; }
        }
        if(start<0) return null;

        const vals=[];
        for(let j=start+2; j<row.length && vals.length<18; j++){
          const raw=String(row[j]||'').trim();
          if(!raw) continue;
          if(raw==='P' || raw==='p' || raw==='\\'){ vals.push(0); continue; }
          const n=parseFloat(raw.replace(/[^0-9.\-]/g,''));
          if(Number.isFinite(n) && n>=0 && n<=6){ vals.push(n); }
        }
        while(vals.length<18) vals.push(0);
        return vals.slice(0,18);
      }

      // -----------------------
      // CourseLayout parser
      // -----------------------

      function parseCourseLayout(lines) {
        let startIdx = -1;
        for (let i = 0; i < lines.length; i++) {
          const k = (lines[i][0] || '').trim().toLowerCase();
          if (k === 'courselayout') {
            startIdx = i;
            break;
          }
        }
        if (startIdx < 0) return null;

        let courseName = '';
        let men = null;
        let women = null;

        let i = startIdx + 1;
        while (i < lines.length) {
          const row = lines[i] || [];
          const key = (row[0] || '').trim().toLowerCase();
          if (!key) { i++; continue; }

          if (key === 'course') {
            courseName = (row[1] || '').trim() || courseName;
            i++;
            continue;
          }

          if (key === 'tee') {
            const teeName = (row[1] || '').trim();
            const genderRaw = (row[2] || '').trim().toUpperCase();
            const gender = genderRaw === 'F' ? 'F' : 'M';

            const header = lines[i + 1] || [];
            const hKey = (header[0] || '').trim().toLowerCase();
            if (hKey !== 'hole') { i++; continue; }

            const colPar = header.findIndex(c => String(c).trim().toLowerCase() === 'par');
            const colYards = header.findIndex(c => String(c).trim().toLowerCase() === 'yards');
            const colSI = header.findIndex(c => String(c).trim().toLowerCase() === 'si');

            const holes = Array(18).fill(null).map((_, idx) => ({
              hole: idx + 1,
              par: 0,
              yards: 0,
              si: 0
            }));

            let j = i + 2;
            while (j < lines.length) {
              const r = lines[j] || [];
              const first = (r[0] || '').trim().toLowerCase();

              if (!first || first === 'tee' || first === 'course' || first === 'courselayout') break;

              const h = parseInt(r[0], 10);
              if (!Number.isFinite(h) || h < 1 || h > 18) break;

              const par = colPar >= 0 ? parseInt(r[colPar] || '0', 10) : 0;
              const yards = colYards >= 0 ? parseInt(r[colYards] || '0', 10) : 0;
              const si = colSI >= 0 ? parseInt(r[colSI] || '0', 10) : 0;

              holes[h - 1] = { hole: h, par, yards, si };
              j++;
            }

            const pars = holes.map(h => h.par || 0);
            const yards = holes.map(h => h.yards || 0);
            const siArr = holes.map(h => h.si || 0);

            if (gender === 'F') {
              women = { pars, yards, si: siArr, teeName };
            } else {
              men = { pars, yards, si: siArr, teeName };
            }

            i = j;
            continue;
          }

          i++;
        }

        if (!men && !women) return null;
        if (!men && women) men = women;
        if (!women && men) women = men;

        return {
          courseName,
          parsMen: men.pars,
          yardsMen: men.yards,
          strokeIndexMen: men.si,
          parsWomen: women.pars,
          yardsWomen: women.yards,
          strokeIndexWomen: women.si
        };
      }

      // -----------------------
      // Main Squabbit CSV parser
      // -----------------------

      function parseSquabbitCSV(text){
        const rows = text.replace(/\r/g,'').split('\n');
        const lines = rows.map(splitSmart);

        // --- fallback PAR row (old CSVs) ---
        let parsedPars=null;
        for(let i=0;i<lines.length;i++){
          const row=lines[i];
          if((row[0]||'').trim().toLowerCase()==='par'){
            const nums=[];
            for(let j=3;j<row.length;j++){
              const cell=String(row[j]||'').trim();
              const n=parseInt(cell,10);
              if(!Number.isNaN(n)) nums.push(n);
            }
            if(nums.length>=19){
              const front = nums.slice(0,9);
              const back  = nums.slice(10,19);
              parsedPars = front.concat(back);
            } else if(nums.length===18){
              parsedPars = nums.slice(0,18);
            }
            break;
          }
        }
        if(!parsedPars || parsedPars.length!==18){
          parsedPars = COURSE_DEFAULT_MEN.slice();
        }

        // --- CourseLayout block (preferred) ---
        const layout = parseCourseLayout(lines);

        let parsMen   = layout?.parsMen   || parsedPars;
        let parsWomen = layout?.parsWomen || parsedPars;
        let yardsMen  = layout?.yardsMen  || COURSE_YARDS_MEN;
        let yardsWomen= layout?.yardsWomen|| COURSE_YARDS_WOMEN;
        let strokeMen = layout?.strokeIndexMen || COURSE_STROKE_INDEX;
        let strokeWomen = layout?.strokeIndexWomen || strokeMen;

        // --- Roster detection (header-based, case-insensitive) ---
        let playerHeaderRow=-1;
        for(let i=0;i<lines.length;i++){
          const row = lines[i] || [];
          const c0 = (row[0]||'').trim().toLowerCase();
          const c1 = (row[1]||'').trim();

          const isNameCol = (c0 === 'name' || c0 === 'player');
          const isHcapCol = /^(hdcp|hcp|handicap|exact handicap)$/i.test(c1);

          if(isNameCol && isHcapCol){
            playerHeaderRow=i; break;
          }
        }

        const players=[];

        if(playerHeaderRow>=0){
          for(let i=playerHeaderRow+1;i<lines.length;i++){
            const row=lines[i];
            if(!row) break;
            const name=(row[0]||'').trim();
            if(!name) break;
            if(isTeamLike(name)) continue;
            if(/^player$/i.test(name)) continue;
            const hcap = parseFloat((row[1]||'').trim());
            if(!Number.isNaN(hcap)){
              players.push({ name, handicap:hcap, gender:'M' });
            }
          }
        }

        // --- Detect gender from tee labels ---
        const genderMap={};
        for(let r=0;r<lines.length;r++){
          const row=lines[r];
          if(!row) continue;
          const nm=(row[0]||'').trim();
          if(!nm) continue;
          const tee=String(row[1]||'').toLowerCase();
          if(/women|ladies|red tee/.test(tee)) genderMap[nm]='F';
          else if(genderMap[nm]==null) genderMap[nm]='M';
        }
        for(const p of players){
          if(genderMap[p.name]) p.gender = genderMap[p.name];
        }

        // --- Summary stableford table (header-driven) ---
        let totalsStart=-1;

        // Prefer: "Stableford" row followed by header row starting "Player"
        for(let i=0;i<lines.length-1;i++){
          const row = lines[i] || [];
          const first = (row[0]||'').trim().toLowerCase();
          if(first==='stableford'){
            const next = lines[i+1] || [];
            const h0 = (next[0]||'').trim().toLowerCase();
            if(h0==='player'){
              totalsStart=i;
              break;
            }
          }
        }

        // Fallback: first "Stableford" row
        if(totalsStart<0){
          for(let i=0;i<lines.length;i++){
            const row=lines[i]||[];
            const first=(row[0]||'').trim().toLowerCase();
            if(first==='stableford'){ totalsStart=i; break; }
          }
        }

        const totals={};

        if(totalsStart>=0){
          for(let i=totalsStart+2;i<lines.length;i++){
            const row=lines[i];
            if(!row) break;
            const name=(row[0]||'').trim();
            if(!name || name==='...' || /^round\s*\d+/i.test(name)) break;
            if(/^(player)$/i.test(name)) continue;
            if(isTeamLike(name)) continue;

            const numeric=[];
            for(let j=1;j<row.length;j++){
              const v=toNum(row[j]);
              if(Number.isFinite(v)) numeric.push(v);
            }
            if(!numeric.length) continue;
            totals[name] = numeric[numeric.length-1];

            if(!players.some(p=>p.name===name)){
              players.push({ name, handicap:0, gender:genderMap[name]||'M' });
            }
          }
        }

        // --- Individual card per-hole extraction (look-ahead for Stableford row) ---
        const holeData = {};
        for (const p of players) {
          let found = false;

          for (let i = 0; i < lines.length - 1; i++) {
            const row = lines[i];
            if (!row) continue;

            if ((row[0] || '').trim() === p.name) {
              // Look a few lines ahead for the Stableford row belonging to this player
              let stRow = null;
              let stIndex = -1;

              for (let k = i + 1; k < Math.min(lines.length, i + 6); k++) {
                const candidate = lines[k] || [];
                const idx = candidate.findIndex(
                  c => String(c).trim().toLowerCase() === 'stableford'
                );
                if (idx !== -1) {
                  stRow = candidate;
                  stIndex = idx;
                  break;
                }
              }

              if (!stRow || stIndex < 0) continue;

              const perHole = readStablefordPerHole(stRow) || Array(18).fill(0);
              const back9 = perHole
                .slice(9)
                .reduce((a, b) => a + (Number(b) || 0), 0);

              const hcapCard = toNum(stRow[stIndex + 1]);

              let totalFromCard = NaN;
              for (let j = stRow.length - 1; j > stIndex; j--) {
                const v = toNum(stRow[j]);
                if (Number.isFinite(v)) {
                  totalFromCard = v;
                  break;
                }
              }

              holeData[p.name] = { perHole, back9, hcapCard, totalFromCard };
              found = true;
              break;
            }
          }

          if (!found) {
            holeData[p.name] = {
              perHole: Array(18).fill(0),
              back9: 0,
              hcapCard: NaN,
              totalFromCard: NaN
            };
          }
        }

        // --- Final cleaned players ---
        const cleaned = players.filter(p =>
          p.name &&
          !/^player$/i.test(p.name.trim()) &&
          !isTeamLike(p.name)
        );

        const finalPlayers = cleaned.map(p=>{
          const card=holeData[p.name]||{};
          const hcapCard = card.hcapCard;
          let handicap = Number.isFinite(p.handicap)?p.handicap:NaN;

          if(!Number.isFinite(handicap) || handicap<=0){
            handicap = Number.isFinite(hcapCard)?hcapCard:0;
          }

          const ptsSummary = totals[p.name];
          const cardTotal = card.totalFromCard;
          let points = 0;
          if(Number.isFinite(ptsSummary)) points = ptsSummary;
          else if(Number.isFinite(cardTotal)) points = cardTotal;

          return {
            name:p.name,
            gender:p.gender||genderMap[p.name]||'M',
            handicap,
            points,
            back9:card.back9||0,
            perHole:card.perHole||[]
          };
        });

        return {
          players: finalPlayers,
          parsMen,
          parsWomen,
          yardsMen,
          yardsWomen,
          strokeIndexMen: strokeMen,
          strokeIndexWomen: strokeWomen
        };
      }

      // ----------------------------------------------------
      // App Component (Winter League)
      // ----------------------------------------------------
      function App() {
        const [view, setView] = useState('home');
        const [selectedPlayer, setSelectedPlayer] = useState('');

        // Supabase config
        const SUPA_URL = "https://mqknahdfpqxrpgpxqtus.supabase.co";
        const SUPA_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1xa25haGRmcHF4cnBncHhxdHVzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0NTU3MDYsImV4cCI6MjA3ODAzMTcwNn0.GTUVsrRJ-MClMg96vuHZpUtAnUFtCsJvuLiiE0D-fCc";

        const BUCKET = "winter_league";
        const STANDINGS_TABLE = "winter_league_standings";
        const PREFIX = "events"; // folder in bucket

        const [client, setClient] = useState(null);
        const [statusMsg, setStatusMsg] = useState("Connecting…");

        const [shared, setShared] = useState([]);
        const [sharedGroups, setSharedGroups] = useState([]);

        const [players, setPlayers] = useState([]);
        const [season, setSeason] = useState({});
        const [eventName, setEventName] = useState("Wednesday Winter League");

        const [coursePars, setCoursePars] = useState({
          men: COURSE_DEFAULT_MEN,
          women: COURSE_DEFAULT_WOMEN
        });

        const [courseYards, setCourseYards] = useState({
          men: COURSE_YARDS_MEN,
          women: COURSE_YARDS_WOMEN
        });

        const [courseStrokeIndex, setCourseStrokeIndex] = useState({
          men: COURSE_STROKE_INDEX,
          women: COURSE_STROKE_INDEX
        });

        const fileInputRef = useRef(null);

        // Init Supabase + fetch season + shared events
        useEffect(() => {
          let cancelled = false;

          async function boot() {
            try {
              if (!(window.supabase && window.supabase.createClient)) {
                setTimeout(boot, 200);
                return;
              }

              const c = window.supabase.createClient(SUPA_URL, SUPA_KEY, {
                auth: { persistSession: false }
              });

              if (cancelled) return;
              setClient(c);

              const probe = await c.from(STANDINGS_TABLE).select('name').limit(1);
              if (probe.error) {
                setStatusMsg('Error: ' + probe.error.message);
              } else {
                setStatusMsg("Connected");
                await refreshShared(c);
                await fetchSeason(c);
              }
            } catch (err) {
              if (!cancelled) setStatusMsg("Error: " + (err?.message || err));
            }
          }

          boot();
          return () => { cancelled = true };
        }, []);

        // Group events by year
        function groupEventsByYear(files) {
          const groups = {};
          for (const f of files) {
            const m = f.name.match(/(20\d{2})/);
            const year = m ? m[1] : 'Unknown';
            (groups[year] ||= []).push(f);
          }
          return Object.keys(groups)
            .sort((a,b)=>b.localeCompare(a))
            .map(y => ({
              year: y,
              events: groups[y].sort((a,b)=>a.name.localeCompare(b.name))
            }));
        }

        // Load shared events from Supabase Storage
        async function refreshShared(c) {
          c = c || client;
          if (!c) return;

          const r = await c.storage.from(BUCKET).list(PREFIX, {
            limit: 1000,
            sortBy: { column: "name", order: "asc" }
          });

          if (r.error) {
            toast("Storage error: " + r.error.message);
            return;
          }

          // RELAXED FILTER: only ignore hidden dot-files, don't require .csv extension
          const data = (r.data || [])
            .filter(x => !x.name.startsWith('.'))
            .map(x => ({
              name: x.name.replace(/\.csv$/i, ''),
              file: x.name,
              path: `${PREFIX}/${x.name}`
            }));

          setShared(data);
          setSharedGroups(groupEventsByYear(data));
        }

        // Load season table from Supabase
        async function fetchSeason(c) {
          c = c || client;
          if (!c) return;

          const r = await c
            .from(STANDINGS_TABLE)
            .select('name,total_points,events,best_event_points,best_hole_points,eclectic_total,best_per_hole');

          if (r.error) {
            setStatusMsg("Error: " + r.error.message);
            return;
          }

          const map = {};
          for (const rec of (r.data || [])) {
            if (isTeamLike(rec.name)) continue;

            let bph = [];
            if (Array.isArray(rec.best_per_hole)) bph = rec.best_per_hole;
            else if (typeof rec.best_per_hole === 'string') {
              try { bph = JSON.parse(rec.best_per_hole) } catch {}
            }

            map[rec.name] = {
              name: rec.name,
              totalPoints: rec.total_points || 0,
              events: rec.events || 0,
              bestEventPoints: rec.best_event_points ?? 0,
              bestHolePoints: rec.best_hole_points ?? 0,
              eclecticTotal: rec.eclectic_total ?? 0,
              bestPerHole: (bph || []).map(n => Number(n)||0)
            };
          }

          setSeason(map);
        }

        // Shared helper to load an event from CSV text
        function loadEventFromText(text, nameForEvent) {
          const parsed = parseSquabbitCSV(text);
          const ps = parsed.players || [];

          setPlayers(ps);
          setSelectedPlayer(ps[0]?.name || "");

          setEventName((nameForEvent || "").replace(/\.[^.]+$/, ""));

          setCoursePars({
            men: parsed.parsMen || COURSE_DEFAULT_MEN,
            women: parsed.parsWomen || parsed.parsMen || COURSE_DEFAULT_WOMEN
          });
          setCourseYards({
            men: parsed.yardsMen || COURSE_YARDS_MEN,
            women: parsed.yardsWomen || COURSE_YARDS_WOMEN
          });
          setCourseStrokeIndex({
            men: parsed.strokeIndexMen || COURSE_STROKE_INDEX,
            women: parsed.strokeIndexWomen || parsed.strokeIndexMen || COURSE_STROKE_INDEX
          });

          setView('event');
        }

        // Load event from Supabase
        async function loadShared(item) {
          if (!client) {
            alert("Supabase client not ready");
            return;
          }

          const r = await client.storage.from(BUCKET).download(item.path);
          if (r.error) {
            alert("Download failed: " + r.error.message);
            return;
          }

          const text = await r.data.text();
          loadEventFromText(text, item.name);
          toast("Event loaded");
        }

        // Import CSV (local)
        function importLocalCSV(text, filename) {
          loadEventFromText(text, filename);
        }

        // Countback helper
        function compareByCountback(a,b){
          const pa=a.perHole||[];
          const pb=b.perHole||[];
          const sum=(arr,s,e)=>arr.slice(s,e).reduce((x,y)=>x+(Number(y)||0),0);

          const aB9=sum(pa,9,18), bB9=sum(pb,9,18);
          if(aB9!==bB9) return bB9-aB9;

          const aL6=sum(pa,12,18), bL6=sum(pb,12,18);
          if(aL6!==bL6) return bL6-aL6;

          const aL3=sum(pa,15,18), bL3=sum(pb,15,18);
          if(aL3!==bL3) return bL3-aL3;

          for(let i=17;i>=0;i--){
            const ai=Number(pa[i])||0, bi=Number(pb[i])||0;
            if(ai!==bi) return bi-ai;
          }
          return 0;
        }

        // Compute event leaderboard
        const computed = useMemo(() => {
          if (!players.length) return [];

          const rows = players.map((p,i)=>({
            idx:i,
            name:p.name,
            gender:p.gender,
            startExact:p.handicap,
            points:p.points,
            back9:p.back9,
            perHole:p.perHole
          }));

          const base=[...rows].sort((a,b)=>(b.points-a.points)||compareByCountback(a,b));

          // Group by points using a Map to avoid repeated filters
          const byPoints = new Map();
          for (const r of base) {
            if (!byPoints.has(r.points)) byPoints.set(r.points, []);
            byPoints.get(r.points).push(r);
          }

          // Insertion order follows sorted base (points descending)
          const groups = Array.from(byPoints.values());

          const topGroup = groups[0] || [];
          let best = topGroup.length ? [topGroup[0]] : [];
          for (let k=1;k<topGroup.length;k++){
            const cmp=compareByCountback(topGroup[k],best[0]);
            if(cmp>0) best=[topGroup[k]];
            else if(cmp===0) best.push(topGroup[k]);
          }
          const winnerSet = new Set(best);

          let pos=1;
          const out=[];

          for(const group of groups){
            const ptsValue = POINTS_TABLE[pos-1] || 0;

            for(const r of group){
              const isWinner = winnerSet.has(r) && group === topGroup;

              const hc = computeNewExactHandicap(
                r.startExact,
                r.gender,
                r.points,
                r.back9,
                isWinner
              );

              out.push({
                ...r,
                position:pos,
                leaguePoints:ptsValue,
                isWinner,
                nextExact:hc.nextExact,
                nextPlaying:hc.nextPlaying
              });
            }

            pos += group.length;
          }

          return out.sort((a,b)=>a.position-b.position);
        }, [players]);

        // Season: Add event
        async function addEventToSeason() {
          if (!computed.length) { toast("Load an event first"); return; }
          const next = { ...season };

          for (const r of computed) {
            if (isTeamLike(r.name)) continue;

            const prev = next[r.name] || {
              name:r.name,
              totalPoints:0,
              events:0,
              bestPerHole:Array(18).fill(0),
              eclecticTotal:0,
              bestEventPoints:0,
              bestHolePoints:0
            };

            const eventPerHole = (r.perHole||[]).map(v=>Math.max(0,Math.min(6,Number(v)||0)));

            const bestPerHole = prev.bestPerHole.map((v,i)=>Math.max(v,eventPerHole[i]));
            const eclecticTotal = bestPerHole.reduce((s,v)=>s+v,0);
            const bestEvent = Math.max(prev.bestEventPoints || 0, r.points || 0);
            const bestHole = Math.max(prev.bestHolePoints || 0, Math.max(...eventPerHole));

            next[r.name] = {
              name:r.name,
              totalPoints:(prev.totalPoints||0)+(r.leaguePoints||0),
              events:(prev.events||0)+1,
              bestEventPoints:bestEvent,
              bestHolePoints:bestHole,
              eclecticTotal,
              bestPerHole
            };
          }

          setSeason(next);

          if (client) {
            const vals = Object.values(next).filter(r=>!isTeamLike(r.name));
            const rowsToUpsert = vals.map(r => ({
              name:r.name,
              total_points:r.totalPoints,
              events:r.events,
              best_event_points:r.bestEventPoints,
              best_hole_points:r.bestHolePoints,
              eclectic_total:r.eclecticTotal,
              best_per_hole:r.bestPerHole
            }));

            const res = await client.from(STANDINGS_TABLE).upsert(rowsToUpsert, { onConflict: 'name' });
            if (res.error) toast("Error: " + res.error.message);
            else toast("Event added to season ✓");
          }
        }

        // Season: Remove event
        // NOTE: This only reverses league points & event count.
        // best_per_hole / eclectic / best_event / best_hole are not recomputed from history.
        async function removeEventFromSeason() {
          if (!computed.length) { toast("Load an event first"); return; }
          if (!window.confirm("Remove this event from the season standings?")) return;

          const next = { ...season };
          const oldSeason = season;

          for (const r of computed) {
            const prev = next[r.name];
            if (!prev) continue;

            const newTotal = prev.totalPoints - r.leaguePoints;
            const newEvents = Math.max(0, prev.events - 1);

            if (newTotal <= 0 && newEvents === 0) {
              delete next[r.name];
            } else {
              next[r.name] = { ...prev, totalPoints:newTotal, events:newEvents };
            }
          }

          setSeason(next);

          if (client) {
            const removedNames = Object.keys(oldSeason).filter(k => !next[k]);
            if (removedNames.length) {
              await client.from(STANDINGS_TABLE).delete().in('name', removedNames);
            }

            const vals = Object.values(next).filter(r=>!isTeamLike(r.name));
            const rowsToUpsert = vals.map(r => ({
              name:r.name,
              total_points:r.totalPoints,
              events:r.events,
              best_event_points:r.bestEventPoints,
              best_hole_points:r.bestHolePoints,
              eclectic_total:r.eclecticTotal,
              best_per_hole:r.bestPerHole
            }));

            const res = await client
              .from(STANDINGS_TABLE)
              .upsert(rowsToUpsert, { onConflict:'name' });

            if (res.error) toast("Error: " + res.error.message);
            else toast("Event removed from season ✓");
          }
        }

        // Season: clear
        async function clearSeason() {
          if (!client) { toast("No client"); return; }
          if (!window.confirm("⚠ This will delete ALL season standings. Continue?")) return;

          const res = await client.from(STANDINGS_TABLE).delete().neq('name','');
          if (res.error) toast("Error: " + res.error.message);
          else {
            setSeason({});
            toast("Season cleared");
          }
        }

        // ----------------------------------------------------
        // Components
        // ----------------------------------------------------

        function Header({ eventName, statusMsg }) {
          return (
            <header className="hide-print rounded-2xl p-4 border border-squab-700 bg-squab-600 text-white shadow">
              <div className="flex items-center justify-between gap-2">
                <div>
                  <h1 className="text-xl md:text-2xl font-bold tracking-tight">
                    Wednesday Winter League — League & Eclectic
                  </h1>
                  <p className="text-xs text-white/90">Supabase: {statusMsg}</p>
                </div>
                <span className="hidden sm:inline-flex chip border-white/30 bg-white/10 text-white">
                  {eventName || "Untitled Event"}
                </span>
              </div>
            </header>
          );
        }

        function EventNav({ setView }) {
          return (
            <nav className="flex flex-wrap gap-2 mb-4">
              <button className="chip" onClick={() => setView('event')}>Event</button>
              <button className="chip" onClick={() => setView('ratings')}>Ratings</button>
              <button className="chip" onClick={() => setView('holes')}>Hole Analysis</button>
              <button className="chip" onClick={() => setView('standings')}>Standings</button>
              <button className="chip" onClick={() => setView('eclectic')}>Eclectic</button>
              <button className="chip" onClick={() => setView('home')}>Home</button>
            </nav>
          );
        }

        function Home({ setView, fileInputRef, importLocalCSV, computed, addEventToSeason, removeEventFromSeason, clearSeason }) {
          const canAct = computed.length > 0;
          const [open, setOpen] = useState(true);

          return (
            <section className="rounded-2xl p-3 md:p-4 panel-mint shadow-sm">
              <button
                className="w-full bg-white text-neutral-900 border border-squab-200 rounded-xl px-4 py-3 flex items-center justify-between"
                onClick={() => setOpen(v => !v)}
              >
                <span className="font-semibold">Menu</span>
                <span className={`transition-transform ${open ? 'rotate-180' : ''}`}>▾</span>
              </button>

              <div className={`overflow-hidden transition-all ${open ? 'max-h-[2000px]' : 'max-h-0'}`}>
                <div className="mt-3 grid gap-2">
                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView('past')}
                  >
                    View Past Winter League Events
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView('ratings')}
                  >
                    View Player Ratings
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView('holes')}
                  >
                    Player Hole Analysis
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView('standings')}
                  >
                    Check Season Standings
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView('eclectic')}
                  >
                    Check Eclectic Leaderboard
                  </button>

                  {/* Import CSV */}
                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => fileInputRef.current && fileInputRef.current.click()}
                  >
                    Import CSV
                  </button>

                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".csv"
                    className="hidden"
                    onChange={async e => {
                      const f = e.target.files?.[0];
                      if (!f) return;
                      const text = await f.text();
                      importLocalCSV(text, f.name);
                      e.target.value = '';
                    }}
                  />

                  {/* Add Event to Season */}
                  <button
                    className={`w-full text-left rounded-xl border px-3 py-2 ${
                      canAct ? 'border-squab-200 bg-white' : 'border-neutral-200 bg-neutral-50 text-neutral-400 cursor-not-allowed'
                    }`}
                    onClick={addEventToSeason}
                    disabled={!canAct}
                  >
                    Add Event → Season
                  </button>

                  {/* Remove Event */}
                  <button
                    className={`w-full text-left rounded-xl border px-3 py-2 ${
                      canAct ? 'border-amber-300 bg-amber-50 text-amber-800' : 'border-neutral-200 bg-neutral-50 text-neutral-400 cursor-not-allowed'
                    }`}
                    onClick={removeEventFromSeason}
                    disabled={!canAct}
                  >
                    Remove Event ← Season
                  </button>

                  {/* Delete Season */}
                  <button
                    className="w-full text-left rounded-xl border border-red-300 bg-red-50 px-3 py-2 text-red-700"
                    onClick={clearSeason}
                  >
                    Delete Entire Season
                  </button>
                </div>
              </div>
            </section>
          );
        }

        // Past events screen
        function PastEvents({ sharedGroups, loadShared, setView }) {
          return (
            <section className="rounded-2xl p-3 md:p-4 bg-white border border-squab-200 shadow-sm">
              <div className="flex items-center justify-between mb-2">
                <h2 className="text-lg font-semibold text-squab-900">Past Winter League Events</h2>
                <button className="btn border border-squab-200" onClick={() => setView('home')}>Back</button>
              </div>

              {sharedGroups.length === 0 && (
                <div className="text-sm text-neutral-600 p-2">No shared CSVs yet.</div>
              )}

              {sharedGroups.map(group => (
                <div key={group.year} className="mb-3">
                  <div className="text-xs text-neutral-600 mb-1">{group.year}</div>
                  <select
                    className="w-full rounded-xl border border-squab-200 px-3 py-2 bg-white"
                    onChange={async e => {
                      const idx = e.target.value;
                      if (idx === "") return;
                      const item = group.events[Number(idx)];
                      await loadShared(item);
                    }}
                  >
                    <option value="">Select an event…</option>
                    {group.events.map((item, i) => (
                      <option key={item.path} value={i}>{item.name}</option>
                    ))}
                  </select>
                </div>
              ))}
            </section>
          );
        }

        function EventScreen({ computed, setView }) {
          return (
            <section className="rounded-2xl p-4 md:p-6 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">Event Leaderboard</h2>

              <div className="overflow-auto">
                <table className="min-w-full text-sm">
                  <thead className="sticky top-0 bg-white z-10">
                    <tr className="border-b border-squab-200 text-left">
                      <th>#</th>
                      <th>Name</th>
                      <th>Handicap</th>
                      <th>Stableford</th>
                      <th>Back9</th>
                      <th>Pts</th>
                      <th>New Hcap</th>
                    </tr>
                  </thead>

                  <tbody className="[&_tr:nth-child(even)]:bg-squab-50">
                    {computed.length === 0 && (
                      <tr>
                        <td colSpan="7" className="py-3 text-neutral-600">
                          Load an event to see results.
                        </td>
                      </tr>
                    )}

                    {computed.map((r, i) => (
                      <tr key={i} className="border-b border-squab-200">
                        <td>{r.position}</td>
                        <td className="whitespace-nowrap">{r.name}</td>
                        <td>{Math.round(r.startExact)}</td>
                        <td>{r.points}</td>
                        <td>{r.back9}</td>
                        <td>{r.leaguePoints}</td>
                        <td>{r.nextPlaying}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        function Ratings({ computed, coursePars, setView }) {
          const menPars = coursePars.men;
          const womenPars = coursePars.women;

          const ratingLabel = avg =>
            avg >= 3 ? 'Excellent' :
            avg >= 2.5 ? 'Good' :
            avg >= 2 ? 'Solid' :
            avg >= 1.5 ? 'Needs Work' :
            'Struggle';

          const badgeClass = avg =>
            avg >= 3 ? 'bg-emerald-100 text-emerald-800' :
            avg >= 2.5 ? 'bg-emerald-50 text-emerald-700' :
            avg >= 2 ? 'bg-neutral-100 text-neutral-800' :
            avg >= 1.5 ? 'bg-amber-100 text-amber-800' :
            'bg-red-100 text-red-800';

          const eventParAverages = (perHole, pars) => {
            const sums = {3:{s:0,c:0}, 4:{s:0,c:0}, 5:{s:0,c:0}};
            for (let i=0; i<18; i++) {
              const pts = Number(perHole[i]) || 0;
              const par = pars[i] || 4;
              if (sums[par]) {
                sums[par].s += pts;
                sums[par].c++;
              }
            }
            const avg = t => sums[t].c ? sums[t].s / sums[t].c : 0;
            return {
              p3: avg(3),
              p4: avg(4),
              p5: avg(5)
            };
          };

          const ratings = useMemo(() => {
            return computed.map(r => {
              const pars = r.gender === 'F' ? womenPars : menPars;
              const av = eventParAverages(r.perHole, pars);
              return {
                name: r.name,
                p3: to1(av.p3),
                p4: to1(av.p4),
                p5: to1(av.p5),
                total: to1(av.p3 + av.p4 + av.p5)
              };
            }).sort((a,b)=>b.total-a.total);
          }, [computed, menPars, womenPars]);

          return (
            <section className="rounded-2xl p-3 md:p-5 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">Player Ratings</h2>

              <div className="overflow-auto">
                <table className="min-w-full text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 text-left">
                      <th>Name</th>
                      <th>Par-3 Avg</th>
                      <th>Rating</th>
                      <th>Par-4 Avg</th>
                      <th>Rating</th>
                      <th>Par-5 Avg</th>
                      <th>Rating</th>
                    </tr>
                  </thead>

                  <tbody>
                    {ratings.map(r => (
                      <tr key={r.name} className="border-b border-squab-200">
                        <td className="font-medium">{r.name}</td>

                        <td>{r.p3.toFixed(1)}</td>
                        <td>
                          <span className={`px-2 py-0.5 rounded-lg text-xs ${badgeClass(r.p3)}`}>
                            {ratingLabel(r.p3)}
                          </span>
                        </td>

                        <td>{r.p4.toFixed(1)}</td>
                        <td>
                          <span className={`px-2 py-0.5 rounded-lg text-xs ${badgeClass(r.p4)}`}>
                            {ratingLabel(r.p4)}
                          </span>
                        </td>

                        <td>{r.p5.toFixed(1)}</td>
                        <td>
                          <span className={`px-2 py-0.5 rounded-lg text-xs ${badgeClass(r.p5)}`}>
                            {ratingLabel(r.p5)}
                          </span>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        function Standings({ season, setView }) {
          const list = Object.values(season)
            .filter(r => !isTeamLike(r.name))
            .sort((a,b)=>(b.totalPoints-a.totalPoints)||a.name.localeCompare(b.name));

          return (
            <section className="rounded-2xl p-3 md:p-5 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">Season Standings</h2>

              <div className="overflow-auto">
                <table className="min-w-full text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 text-left">
                      <th>Rank</th>
                      <th>Name</th>
                      <th>Events</th>
                      <th>Total</th>
                      <th>Best Event</th>
                      <th>Best Hole</th>
                      <th>Eclectic</th>
                    </tr>
                  </thead>

                  <tbody>
                    {list.map((r,i)=>(
                      <tr key={r.name} className="border-b border-squab-200">
                        <td>{i+1}</td>
                        <td>{r.name}</td>
                        <td>{r.events}</td>
                        <td>{r.totalPoints}</td>
                        <td>{r.bestEventPoints}</td>
                        <td>{r.bestHolePoints}</td>
                        <td>{r.eclecticTotal}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        function Eclectic({ season, setView }) {
          const list = Object.values(season)
            .filter(r => !isTeamLike(r.name))
            .sort((a,b)=>((b.eclecticTotal||0)-(a.eclecticTotal||0)));

          return (
            <section className="rounded-2xl p-3 md:p-5 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">Eclectic Leaderboard</h2>

              <div className="overflow-auto">
                <table className="min-w-full text-xs md:text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 text-left">
                      <th>Rank</th>
                      <th>Name</th>
                      <th>Eclectic Total</th>
                      {Array.from({length:18},(_,i)=>(<th key={i}>H{i+1}</th>))}
                    </tr>
                  </thead>

                  <tbody>
                    {list.map((r,i)=>(
                      <tr key={r.name} className="border-b border-squab-200">
                        <td>{i+1}</td>
                        <td>{r.name}</td>
                        <td>{r.eclecticTotal}</td>
                        {(r.bestPerHole||Array(18).fill(0)).map((v,ix)=>(
                          <td key={ix}>{v}</td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        function HoleAnalysis({
          computed,
          selectedPlayer,
          setSelectedPlayer,
          coursePars,
          courseYards,
          strokeIndexMen,
          strokeIndexWomen,
          setView
        }) {
          if (!computed.length) {
            return (
              <section className="rounded-2xl p-4 bg-white border border-squab-200 shadow-sm">
                <EventNav setView={setView} />
                <p className="text-neutral-600">Load an event to see hole analysis.</p>
              </section>
            );
          }

          const playerNames = computed.map((p) => p.name);
          const player = computed.find((p) => p.name === selectedPlayer) || computed[0];

          const perHole = player.perHole || Array(18).fill(0);
          const pars = coursePars[player.gender === "F" ? "women" : "men"];
          const yards = courseYards[player.gender === "F" ? "women" : "men"];

          const siMenArr = strokeIndexMen || [];
          const siWomenArr = strokeIndexWomen || siMenArr;
          const siArr = player.gender === "F" ? siWomenArr : siMenArr;

          // Field averages
          const fieldAvg = Array(18).fill(0);
          for (let h = 0; h < 18; h++) {
            const vals = computed.map((p) => Number(p.perHole[h]) || 0);
            fieldAvg[h] = vals.reduce((a, b) => a + b, 0) / vals.length;
          }

          const gains = perHole.map((p, i) => p - fieldAvg[i]);
          const totalGain = gains.reduce((a, b) => a + b, 0);

          const bestHole = gains
            .map((g, i) => ({ hole: i + 1, g }))
            .sort((a, b) => b.g - a.g)[0];

          const worstHole = gains
            .map((g, i) => ({ hole: i + 1, g }))
            .sort((a, b) => a.g - b.g)[0];

          const par3 = [], par4 = [], par5 = [];
          for (let i = 0; i < 18; i++) {
            if (pars[i] === 3) par3.push(perHole[i]);
            if (pars[i] === 4) par4.push(perHole[i]);
            if (pars[i] === 5) par5.push(perHole[i]);
          }
          const avgP3 = par3.reduce((a, b) => a + b, 0) / (par3.length || 1);
          const avgP4 = par4.reduce((a, b) => a + b, 0) / (par4.length || 1);
          const avgP5 = par5.reduce((a, b) => a + b, 0) / (par5.length || 1);

          const holeType = (h) => {
            const par = pars[h];
            const yd = yards[h];
            if (par === 3) return "Par 3";
            if (par === 4) return yd >= 400 ? "Long Par 4" : "Par 4";
            if (par === 5) return yd >= 520 ? "Long Par 5" : "Par 5";
            return "Unknown";
          };

          return (
            <section className="rounded-2xl p-4 md:p-6 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">
                Player Hole Analysis
              </h2>

              <div className="mb-4">
                <label className="block text-sm font-medium mb-1">Select Player</label>
                <select
                  className="w-full max-w-xs rounded-xl border border-squab-200 px-3 py-2 bg-white"
                  value={selectedPlayer}
                  onChange={(e) => setSelectedPlayer(e.target.value)}
                >
                  {playerNames.map((name) => (
                    <option key={name}>{name}</option>
                  ))}
                </select>
              </div>

              <div className="grid md:grid-cols-3 gap-4 mb-5">
                <div className="p-3 border border-squab-200 rounded-xl bg-squab-50">
                  <div className="text-xs text-neutral-600">Total Gain vs Field</div>
                  <div className="text-xl font-bold">{to1(totalGain)}</div>
                </div>

                <div className="p-3 border border-squab-200 rounded-xl bg-squab-50">
                  <div className="text-xs text-neutral-600">Best Hole</div>
                  <div className="text-xl font-bold">
                    Hole {bestHole.hole} ({to1(bestHole.g)} pts vs field)
                  </div>
                </div>

                <div className="p-3 border border-squab-200 rounded-xl bg-squab-50">
                  <div className="text-xs text-neutral-600">Worst Hole</div>
                  <div className="text-xl font-bold">
                    Hole {worstHole.hole} ({to1(worstHole.g)} pts vs field)
                  </div>
                </div>
              </div>

              <div className="grid md:grid-cols-3 gap-4 mb-6">
                <div className="p-3 bg-white border border-squab-200 rounded-xl">
                  <div className="text-xs text-neutral-600">Avg Par-3 Score</div>
                  <div className="text-xl font-semibold">{to1(avgP3)}</div>
                </div>
                <div className="p-3 bg-white border border-squab-200 rounded-xl">
                  <div className="text-xs text-neutral-600">Avg Par-4 Score</div>
                  <div className="text-xl font-semibold">{to1(avgP4)}</div>
                </div>
                <div className="p-3 bg-white border border-squab-200 rounded-xl">
                  <div className="text-xs text-neutral-600">Avg Par-5 Score</div>
                  <div className="text-xl font-semibold">{to1(avgP5)}</div>
                </div>
              </div>

              <div className="overflow-auto">
                <table className="min-w-full text-xs md:text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 bg-squab-50 text-left">
                      <th>Hole</th>
                      <th>Par</th>
                      <th>Yards</th>
                      <th>SI</th>
                      <th>Pts</th>
                      <th>Field Avg</th>
                      <th>Gain</th>
                      <th>Type</th>
                    </tr>
                  </thead>

                  <tbody>
                    {perHole.map((pts, i) => (
                      <tr key={i} className="border-b">
                        <td>{i + 1}</td>
                        <td>{pars[i]}</td>
                        <td>{yards[i]}</td>
                        <td>{siArr[i]}</td>
                        <td className="font-semibold">{pts}</td>
                        <td>{to1(fieldAvg[i])}</td>
                        <td
                          className={
                            gains[i] >= 0
                              ? "text-emerald-600 font-semibold"
                              : "text-red-600 font-semibold"
                          }
                        >
                          {to1(gains[i])}
                        </td>
                        <td>{holeType(i)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        // Main app render
        return (
          <div className="min-h-screen p-4 sm:p-6">
            <div className="max-w-5xl mx-auto space-y-4">
              <Header eventName={eventName} statusMsg={statusMsg} />

              {view === 'home' && (
                <Home
                  setView={setView}
                  fileInputRef={fileInputRef}
                  importLocalCSV={importLocalCSV}
                  computed={computed}
                  addEventToSeason={addEventToSeason}
                  removeEventFromSeason={removeEventFromSeason}
                  clearSeason={clearSeason}
                />
              )}

              {view === 'past' && (
                <PastEvents
                  sharedGroups={sharedGroups}
                  loadShared={loadShared}
                  setView={setView}
                />
              )}

              {view === 'event' && (
                <EventScreen
                  computed={computed}
                  setView={setView}
                />
              )}

              {view === 'ratings' && (
                <Ratings
                  computed={computed}
                  coursePars={coursePars}
                  setView={setView}
                />
              )}

              {view === 'holes' && (
                <HoleAnalysis
                  computed={computed}
                  selectedPlayer={selectedPlayer}
                  setSelectedPlayer={setSelectedPlayer}
                  coursePars={coursePars}
                  courseYards={courseYards}
                  strokeIndexMen={courseStrokeIndex.men}
                  strokeIndexWomen={courseStrokeIndex.women}
                  setView={setView}
                />
              )}

              {view === 'standings' && (
                <Standings
                  season={season}
                  setView={setView}
                />
              )}

              {view === 'eclectic' && (
                <Eclectic
                  season={season}
                  setView={setView}
                />
              )}
            </div>
          </div>
        );
      }

      // Mount React App
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
