<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Wednesday Winter League — Events & Eclectic</title>
    <link rel="icon" href="./favicon.ico" />
    <meta name="theme-color" content="#199f57" />
    <meta
      property="og:title"
      content="Wednesday Winter League — Events & Eclectic"
    />
    <meta
      property="og:description"
      content="Winter League event results, ratings, standings, player hole analysis and eclectic leaderboard."
    />

    <!-- Umami Analytics -->
    <script
      defer
      src="https://cloud.umami.is/script.js"
      data-website-id="06bb64bb-1c9b-4d57-9a9a-e477fb8326be"
    ></script>

    <!-- Tailwind Config FIRST -->
    <script>
      window.tailwind = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              squab: {
                50: "#eefbf2",
                100: "#d8f5e3",
                200: "#b4eac9",
                300: "#86dbab",
                400: "#55c787",
                500: "#2fb66a",
                600: "#199f57",
                700: "#147f47",
                800: "#12663b",
                900: "#0f5232"
              }
            }
          }
        }
      };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React + Babel + Supabase (UMD builds) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

    <!-- Base styles -->
    <style>
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
      }
      .chip {
        padding: 0.3rem 0.65rem;
        border-radius: 0.5rem;
        border: 1px solid #c6e7d0;
        background: #eefbf2;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background 0.15s, transform 0.15s;
      }
      .chip:hover {
        background: #dff7e6;
        transform: translateY(-1px);
      }
      .btn {
        padding: 0.5rem 0.75rem;
        border-radius: 0.75rem;
        transition: all 0.15s ease;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      }
      .panel-mint {
        background: #eefbf2;
        border: 1px solid #b4eac9;
      }
      @media print {
        .hide-print {
          display: none !important;
        }
      }
    </style>
  </head>

  <body class="bg-neutral-50 text-neutral-900">
    <div id="root"></div>

    <!-- React App -->
    <script type="text/babel" data-presets="react">
      /* global React, ReactDOM, supabase */

      const { useState, useEffect, useMemo, useRef } = React;

      // -----------------------
      // Utility Functions
      // -----------------------

      const POINTS_TABLE = [20, 17, 15, 13, 11, 9, 8, 7, 6, 5, 4, 3, 2, 1];
      const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

      const csvEscape = (s) => {
        if (s == null) return "";
        const str = String(s);
        return /[",\n]/.test(str) ? '"' + str.replace(/"/g, '""') + '"' : str;
      };

      const downloadCSV = (filename, rows) => {
        const csv = rows.map((r) => r.map(csvEscape).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
      };

      const to1 = (x) => Math.round((Number(x) || 0) * 10) / 10;

      function toast(msg) {
        try {
          const t = document.createElement("div");
          t.className =
            "fixed bottom-4 right-4 left-4 md:left-auto md:right-4 px-3 py-2 rounded-lg bg-black text-white text-sm shadow z-50 text-center";
          t.textContent = msg;
          document.body.appendChild(t);
          setTimeout(() => {
            t.style.opacity = "0";
            t.style.transition = "opacity .2s";
            setTimeout(() => t.remove(), 220);
          }, 1400);
        } catch {}
      }

      // -----------------------
      // Handicap Maths
      // -----------------------

      function playingCapByGender(g) {
        return g === "F" ? 36 : 28;
      }
      function rangeForHcap(h) {
        if (h <= 9) return "0-9";
        if (h <= 18) return "10-18";
        if (h <= 28) return "19-28";
        return "29-36";
      }
      function cutPerPointOver34(h) {
        const r = rangeForHcap(h);
        return r === "0-9" ? 0.5 : r === "10-18" ? 1 : r === "19-28" ? 1 : 1.5;
      }
      function winnerBonusCut(h) {
        const r = rangeForHcap(h);
        return r === "0-9" ? 1 : r === "10-18" ? 2 : r === "19-28" ? 2.5 : 3;
      }
      function computeNewExactHandicap(start, g, pts, b9, isWinner) {
        const startPlay = Math.round(start);
        let exact = start;

        if (pts >= 35) {
          exact -= cutPerPointOver34(startPlay) * (pts - 34);
        } else if (pts <= 31) {
          exact += 0.5 * (32 - pts);
        }

        if (isWinner) exact -= winnerBonusCut(startPlay);

        const max = playingCapByGender(g);
        const bounded = clamp(exact, 0, 60);
        const nextPlay = clamp(Math.round(bounded), 0, max);

        return {
          nextExact: bounded,
          nextPlaying: nextPlay
        };
      }

      // --- Shared Gross-Strokes Helpers (for Ratings & HoleAnalysis) ---

      function playingHandicapFromExact(exact) {
        return Math.max(0, Math.round(Number(exact) || 0));
      }

      // h = playing handicap, si = stroke index (1..18)
      function strokesReceivedForHole(si, h) {
        const s = Number(si) || 0;
        const H = Number(h) || 0;
        if (H <= 0 || s <= 0 || s > 18) return 0;

        if (H < s && H <= 18) return 0;

        if (H < s && H > 18) {
          // with H>18, everyone gets at least 1 shot per hole, but we still use general formula below
        }

        if (H < s) return 0;

        // shots = 1 + floor((H - si)/18) when H >= si
        return 1 + Math.floor((H - s) / 18);
      }

      // Stableford → NET strokes vs par (handicap still applied)
      function netVsParFromPoints(pts) {
        const p = Number(pts) || 0;
        if (p <= 0) return 2; // treat 0 pts as net double (or worse) over par
        // 1pt = +1, 2pt = 0, 3pt = -1, 4pt = -2, etc.
        return 2 - p;
      }

      // -----------------------
      // CSV Parsing helpers
      // -----------------------

      const isTeamLike = (name) => {
        const s = (name || "").trim();
        return (
          /^players?$/i.test(s) ||
          /^team(\s*\d+)?$/i.test(s) ||
          /^team average$/i.test(s) ||
          /^stableford$/i.test(s) ||
          /^strokeplay$/i.test(s) ||
          /^round\s*\d+$/i.test(s) ||
          /^(out|in|total|s\.i\.|par)$/i.test(s)
        );
      };

      function splitSmart(raw) {
        const d = raw.includes("\t") ? "\t" : raw.includes(";") ? ";" : ",";
        return raw.split(d).map((s) => (s || "").replace(/^"|"$/g, "").trim());
      }
      function toNum(x) {
        const v = parseFloat(String(x == null ? "" : x).replace(/[^0-9.\-]/g, ""));
        return Number.isFinite(v) ? v : NaN;
      }

      // Read per-hole Stableford for an individual card
      function readStablefordPerHole(row) {
        let start = -1;
        for (let i = 0; i < row.length; i++) {
          if (String(row[i]).trim().toLowerCase() === "stableford") {
            start = i;
            break;
          }
        }
        if (start < 0) return null;

        const vals = [];
        for (let j = start + 2; j < row.length && vals.length < 18; j++) {
          const raw = String(row[j] || "").trim();
          if (!raw) continue;
          if (raw === "P" || raw === "p" || raw === "\\") {
            vals.push(0);
            continue;
          }
          const n = parseFloat(raw.replace(/[^0-9.\-]/g, ""));
          if (Number.isFinite(n) && n >= 0 && n <= 6) {
            vals.push(n);
          }
        }
        while (vals.length < 18) vals.push(0);
        return vals.slice(0, 18);
      }

      // -----------------------
      // CourseLayout parser (multi-tee + simple FINAL support)
      // -----------------------

      function parseMultiTeeCourseLayout(lines, startIdx) {
        let courseName = "";
        const tees = [];

        let i = startIdx + 1;
        while (i < lines.length) {
          const row = lines[i] || [];
          const key = (row[0] || "").trim().toLowerCase();

          if (!key) {
            i++;
            continue;
          }
          if (key === "courselayout") break;

          if (key === "course") {
            courseName = (row[1] || "").trim() || courseName;
            i++;
            continue;
          }

          if (key === "tee") {
            const teeName = (row[1] || "").trim();
            const genderRaw = (row[2] || "").trim().toUpperCase();
            const gender = genderRaw === "F" ? "F" : "M";

            const header = lines[i + 1] || [];
            const hKey = (header[0] || "").trim().toLowerCase();
            if (hKey !== "hole") {
              i++;
              continue;
            }

            const colPar = header.findIndex(
              (c) => String(c).trim().toLowerCase() === "par"
            );
            const colYards = header.findIndex(
              (c) => String(c).trim().toLowerCase() === "yards"
            );
            const colSI = header.findIndex(
              (c) => String(c).trim().toLowerCase() === "si"
            );

            if (colYards < 0 || colPar < 0 || colSI < 0) {
              i += 2;
              continue;
            }

            const holes = Array(18)
              .fill(null)
              .map((_, idx) => ({
                hole: idx + 1,
                par: 0,
                yards: 0,
                si: 0
              }));

            let j = i + 2;
            while (j < lines.length) {
              const r = lines[j] || [];
              const first = (r[0] || "").trim().toLowerCase();

              if (!first || first === "tee" || first === "course" || first === "courselayout")
                break;

              const h = parseInt(r[0], 10);
              if (!Number.isFinite(h) || h < 1 || h > 18) break;

              const par = parseInt(r[colPar] || "0", 10);
              const yards = parseInt(r[colYards] || "0", 10);
              const si = parseInt(r[colSI] || "0", 10);

              holes[h - 1] = { hole: h, par, yards, si };
              j++;
            }

            const pars = holes.map((h) => h.par || 0);
            const yards = holes.map((h) => h.yards || 0);
            const siArr = holes.map((h) => h.si || 0);

            tees.push({ teeName, gender, pars, yards, si: siArr });

            i = j;
            continue;
          }

          i++;
        }

        if (!tees.length) return null;
        return { courseName, tees };
      }

      function parseSimpleCourseLayout(lines, startIdx) {
        let headerIdx = -1;
        for (let i = startIdx + 1; i < lines.length; i++) {
          const row = lines[i] || [];
          const first = (row[0] || "").trim().toLowerCase();
          if (!first) continue;
          if (first === "courselayout") break;
          if (first === "hole") {
            headerIdx = i;
            break;
          }
        }
        if (headerIdx < 0) return null;

        const header = lines[headerIdx].map((h) => String(h || ""));
        const norm = (s) => s.replace(/\s+/g, "").toLowerCase();

        const idxMensYards = header.findIndex((c) => norm(c) === "mensyards");
        const idxMensPar = header.findIndex((c) => norm(c) === "menspar");
        const idxMensSI = header.findIndex((c) => norm(c) === "menssi");

        const idxWomYards = header.findIndex(
          (c) => norm(c) === "womensyards" || norm(c) === "ladiesyards"
        );
        const idxWomPar = header.findIndex(
          (c) => norm(c) === "womenspar" || norm(c) === "ladiespar"
        );
        const idxWomSI = header.findIndex(
          (c) => norm(c) === "womenssi" || norm(c) === "ladiessi"
        );

        if (idxMensYards < 0 || idxMensPar < 0 || idxMensSI < 0) {
          return null;
        }

        const holesMen = Array(18)
          .fill(null)
          .map((_, idx) => ({
            hole: idx + 1,
            par: 0,
            yards: 0,
            si: 0
          }));

        const holesWom = Array(18)
          .fill(null)
          .map((_, idx) => ({
            hole: idx + 1,
            par: 0,
            yards: 0,
            si: 0
          }));

        let i = headerIdx + 1;
        while (i < lines.length) {
          const row = lines[i] || [];
          const first = (row[0] || "").trim().toLowerCase();
          if (!first || first === "courselayout") break;

          const h = parseInt(row[0], 10);
          if (!Number.isFinite(h) || h < 1 || h > 18) break;

          const mPar = parseInt(row[idxMensPar] || "0", 10);
          const mYards = parseInt(row[idxMensYards] || "0", 10);
          const mSI = parseInt(row[idxMensSI] || "0", 10);

          holesMen[h - 1] = { hole: h, par: mPar, yards: mYards, si: mSI };

          if (idxWomPar >= 0 && idxWomYards >= 0 && idxWomSI >= 0) {
            const wPar = parseInt(row[idxWomPar] || "0", 10);
            const wYards = parseInt(row[idxWomYards] || "0", 10);
            const wSI = parseInt(row[idxWomSI] || "0", 10);
            holesWom[h - 1] = { hole: h, par: wPar, yards: wYards, si: wSI };
          }

          i++;
        }

        const parsMen = holesMen.map((h) => h.par || 0);
        const yardsMen = holesMen.map((h) => h.yards || 0);
        const siMen = holesMen.map((h) => h.si || 0);

        const tees = [
          { teeName: "Men", gender: "M", pars: parsMen, yards: yardsMen, si: siMen }
        ];

        const hasWomenData =
          idxWomYards >= 0 &&
          idxWomPar >= 0 &&
          idxWomSI >= 0 &&
          holesWom.some((h) => h.par > 0 || h.yards > 0 || h.si > 0);

        if (hasWomenData) {
          const parsWomen = holesWom.map((h) => h.par || 0);
          const yardsWomen = holesWom.map((h) => h.yards || 0);
          const siWomen = holesWom.map((h) => h.si || 0);

          tees.push({
            teeName: "Women",
            gender: "F",
            pars: parsWomen,
            yards: yardsWomen,
            si: siWomen
          });
        }

        return { courseName: "", tees };
      }

      function parseCourseLayout(lines) {
        let startIdx = -1;
        for (let i = 0; i < lines.length; i++) {
          const first = (lines[i][0] || "").trim().toLowerCase();
          if (first === "courselayout") {
            startIdx = i;
            break;
          }
        }
        if (startIdx < 0) return null;

        let hasTee = false;
        for (let i = startIdx + 1; i < lines.length; i++) {
          const first = (lines[i][0] || "").trim().toLowerCase();
          if (first === "tee") {
            hasTee = true;
            break;
          }
          if (first === "courselayout") break;
        }

        if (hasTee) {
          return parseMultiTeeCourseLayout(lines, startIdx);
        } else {
          return parseSimpleCourseLayout(lines, startIdx);
        }
      }

      // Choose tee for a player based on teeLabel and gender
      function chooseTeeForPlayer(player, courseTees) {
        if (!courseTees || !courseTees.length) return null;
        const label = (player.teeLabel || "").toLowerCase();
        const gender = (player.gender || "M").toUpperCase();

        // 1) exact tee name match
        if (label) {
          let t = courseTees.find(
            (tt) => (tt.teeName || "").toLowerCase() === label
          );
          if (t) return t;

          // 2) fuzzy contains match
          t = courseTees.find((tt) => {
            const n = (tt.teeName || "").toLowerCase();
            return n && (n.includes(label) || label.includes(n));
          });
          if (t) return t;
        }

        // 3) match by gender
        let t = courseTees.find(
          (tt) => (tt.gender || "M").toUpperCase() === gender
        );
        if (t) return t;

        // 4) no match – be strict, no default tee
        return null;
      }

      // -----------------------
      // Main Squabbit CSV parser
      // -----------------------

      function parseSquabbitCSV(text) {
        const rows = text.replace(/\r/g, "").split("\n");
        const lines = rows.map(splitSmart);

        // Optional PAR row (backup for missing pars in CourseLayout)
        let parsedPars = null;
        for (let i = 0; i < lines.length; i++) {
          const row = lines[i];
          if ((row[0] || "").trim().toLowerCase() === "par") {
            const nums = [];
            for (let j = 3; j < row.length; j++) {
              const cell = String(row[j] || "").trim();
              const n = parseInt(cell, 10);
              if (!Number.isNaN(n)) nums.push(n);
            }
            if (nums.length >= 19) {
              const front = nums.slice(0, 9);
              const back = nums.slice(10, 19);
              parsedPars = front.concat(back);
            } else if (nums.length === 18) {
              parsedPars = nums.slice(0, 18);
            }
            break;
          }
        }

        // CourseLayout block (REQUIRED to get yardages)
        const layoutRaw = parseCourseLayout(lines);

        if (!layoutRaw || !Array.isArray(layoutRaw.tees) || layoutRaw.tees.length === 0) {
          throw new Error("No CourseLayout block found in CSV (Winter League).");
        }

        // Validate tees
        const tees = layoutRaw.tees.map((t) => {
          const yards = t.yards || [];
          const parsIn = t.pars || [];
          const siIn = t.si || [];

          if (!yards.length || yards.length !== 18 || yards.every((y) => !y)) {
            throw new Error(`Tee "${t.teeName}" has invalid or missing yards.`);
          }

          let pars = parsIn;
          if (!pars || pars.length !== 18 || pars.every((p) => !p)) {
            if (parsedPars && parsedPars.length === 18) {
              pars = parsedPars.slice();
            } else {
              throw new Error(
                `Tee "${t.teeName}" has no valid pars in CourseLayout or PAR row.`
              );
            }
          }

          let si = siIn;
          if (!si || si.length !== 18 || si.every((v) => !v)) {
            throw new Error(
              `Tee "${t.teeName}" has invalid stroke index in CourseLayout.`
            );
          }

          return {
            teeName: t.teeName || "",
            gender: (t.gender || "M").toUpperCase(),
            pars,
            yards,
            si
          };
        });

        // Roster detection
        let playerHeaderRow = -1;
        for (let i = 0; i < lines.length; i++) {
          if ((lines[i][0] || "") === "Name" && (lines[i][1] || "") === "Hdcp") {
            playerHeaderRow = i;
            break;
          }
        }

        const players = [];

        if (playerHeaderRow >= 0) {
          for (let i = playerHeaderRow + 1; i < lines.length; i++) {
            const row = lines[i];
            if (!row) break;
            const name = (row[0] || "").trim();
            if (!name) break;
            if (isTeamLike(name)) continue;
            if (/^player$/i.test(name)) continue;
            const hcap = parseFloat((row[1] || "").trim());
            if (!Number.isNaN(hcap)) {
              players.push({ name, handicap: hcap, gender: "M", teeLabel: "" });
            }
          }
        }

        // Detect gender + tee label from tee mapping rows
        const genderMap = {};
        const teeLabelMap = {};

        for (let r = 0; r < lines.length; r++) {
          const row = lines[r];
          if (!row) continue;
          const nm = (row[0] || "").trim();
          if (!nm) continue;

          const col1 = (row[1] || "").trim();
          if (!col1) continue;

          const teeLower = col1.toLowerCase();
          teeLabelMap[nm] = col1;

          if (/women|ladies|red tee|redtees?/.test(teeLower)) {
            genderMap[nm] = "F";
          } else if (genderMap[nm] == null) {
            genderMap[nm] = "M";
          }
        }

        for (const p of players) {
          if (genderMap[p.name]) p.gender = genderMap[p.name];
          if (teeLabelMap[p.name]) p.teeLabel = teeLabelMap[p.name];
        }

        // Summary stableford table
        let totalsStart = -1;
        for (let i = 0; i < lines.length; i++) {
          const first = (lines[i][0] || "").trim().toLowerCase();
          if (first === "stableford") {
            totalsStart = i;
            break;
          }
        }

        const totals = {};

        if (totalsStart >= 0) {
          for (let i = totalsStart + 2; i < lines.length; i++) {
            const row = lines[i];
            if (!row) break;
            const name = (row[0] || "").trim();
            if (!name || name === "..." || /^round\s*\d+/i.test(name)) break;
            if (/^(player)$/i.test(name)) continue;
            if (isTeamLike(name)) continue;

            const numeric = [];
            for (let j = 1; j < row.length; j++) {
              const v = toNum(row[j]);
              if (Number.isFinite(v)) numeric.push(v);
            }
            if (!numeric.length) continue;
            totals[name] = numeric[numeric.length - 1];

            if (!players.some((p) => p.name === name)) {
              players.push({
                name,
                handicap: 0,
                gender: genderMap[name] || "M",
                teeLabel: teeLabelMap[name] || ""
              });
            }
          }
        }

        // Individual card per-hole extraction
        const holeData = {};
        for (const p of players) {
          let found = false;
          for (let i = 0; i < lines.length - 1; i++) {
            const row = lines[i];
            if (!row) continue;
            if ((row[0] || "").trim() === p.name) {
              const stRow = lines[i + 1] || [];
              let stIndex = -1;
              for (let j = 0; j < stRow.length; j++) {
                if (String(stRow[j]).trim().toLowerCase() === "stableford") {
                  stIndex = j;
                  break;
                }
              }
              if (stIndex < 0) continue;

              const perHole = readStablefordPerHole(stRow);
              const back9 = perHole
                .slice(9)
                .reduce((a, b) => a + (Number(b) || 0), 0);
              const hcapCard = toNum(stRow[stIndex + 1]);

              let totalFromCard = NaN;
              for (let j = stRow.length - 1; j > stIndex; j--) {
                const v = toNum(stRow[j]);
                if (Number.isFinite(v)) {
                  totalFromCard = v;
                  break;
                }
              }

              holeData[p.name] = { perHole, back9, hcapCard, totalFromCard };
              found = true;
              break;
            }
          }
          if (!found) {
            holeData[p.name] = {
              perHole: Array(18).fill(0),
              back9: 0,
              hcapCard: NaN,
              totalFromCard: NaN
            };
          }
        }

        // Final cleaned players
        const cleaned = players.filter(
          (p) =>
            p.name &&
            !/^player$/i.test(p.name.trim()) &&
            !isTeamLike(p.name)
        );

        const finalPlayers = cleaned.map((p) => {
          const card = holeData[p.name] || {};
          const hcapCard = card.hcapCard;

          // ✅ Prefer playing handicap from the Stableford card
          let handicap;
          if (Number.isFinite(hcapCard) && hcapCard > 0) {
            handicap = hcapCard;
          } else if (Number.isFinite(p.handicap) && p.handicap > 0) {
            handicap = p.handicap;
          } else {
            handicap = 0;
          }

          const ptsSummary = totals[p.name];
          const cardTotal = card.totalFromCard;
          let points = 0;
          if (Number.isFinite(ptsSummary)) points = ptsSummary;
          else if (Number.isFinite(cardTotal)) points = cardTotal;

          return {
            name: p.name,
            gender: p.gender || genderMap[p.name] || "M",
            teeLabel: p.teeLabel || teeLabelMap[p.name] || "",
            handicap,
            points,
            back9: card.back9 || 0,
            perHole: card.perHole || []
          };
        });

        return {
          players: finalPlayers,
          courseTees: tees,
          courseName: layoutRaw.courseName || ""
        };
      }

      // ----------------------------------------------------
      // App Component (Winter League)
      // ----------------------------------------------------
      function App() {
        const [view, setView] = useState("home");
        const [selectedPlayer, setSelectedPlayer] = useState("");

        // Supabase config – Winter League
        const SUPA_URL = "https://mqknahdfpqxrpgpxqtus.supabase.co";
        const SUPA_KEY =
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1xa25haGRmcHF4cnBncHhxdHVzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0NTU3MDYsImV4cCI6MjA3ODAzMTcwNn0.GTUVsrRJ-MClMg96vuHZpUtAnUFtCsJvuLiiE0D-fCc";

        const BUCKET = "winter_league";
        const STANDINGS_TABLE = "winter_league_standings";
        const PREFIX = "events";

        const [client, setClient] = useState(null);
        const [statusMsg, setStatusMsg] = useState("Connecting…");

        const [sharedGroups, setSharedGroups] = useState([]);

        const [players, setPlayers] = useState([]);
        const [season, setSeason] = useState({});
        const [eventName, setEventName] = useState("Wednesday Winter League");
        const [courseTees, setCourseTees] = useState([]);
        const [courseName, setCourseName] = useState("");

        const fileInputRef = useRef(null);

        // Init Supabase + fetch season + shared events
        useEffect(() => {
          let cancelled = false;

          async function boot() {
            try {
              if (!(window.supabase && window.supabase.createClient)) {
                setTimeout(boot, 200);
                return;
              }

              const c = window.supabase.createClient(SUPA_URL, SUPA_KEY, {
                auth: { persistSession: false }
              });

              if (cancelled) return;
              setClient(c);

              const probe = await c.from(STANDINGS_TABLE).select("name").limit(1);
              if (probe.error) {
                setStatusMsg("Error: " + probe.error.message);
              } else {
                setStatusMsg("Connected");
                await refreshShared(c);
                await fetchSeason(c);
              }
            } catch (err) {
              if (!cancelled) setStatusMsg("Error: " + (err?.message || err));
            }
          }

          boot();
          return () => {
            cancelled = true;
          };
        }, []);

        function groupEventsByYear(files) {
          const groups = {};
          for (const f of files) {
            const m = f.name.match(/(20\d{2})/);
            const year = m ? m[1] : "Unknown";
            (groups[year] ||= []).push(f);
          }
          return Object.keys(groups)
            .sort((a, b) => b.localeCompare(a))
            .map((y) => ({
              year: y,
              events: groups[y].sort((a, b) => a.name.localeCompare(b.name))
            }));
        }

        async function refreshShared(c) {
          c = c || client;
          if (!c) return;

          const r = await c.storage.from(BUCKET).list(PREFIX, {
            limit: 1000,
            sortBy: { column: "name", order: "asc" }
          });

          if (r.error) {
            toast("Storage error: " + r.error.message);
            return;
          }

          const data = (r.data || [])
            .filter((x) => !x.name.startsWith("."))
            .map((x) => ({
              name: x.name.replace(/\.csv$/i, ""),
              file: x.name,
              path: `${PREFIX}/${x.name}`
            }));

          setSharedGroups(groupEventsByYear(data));
        }

        async function loadShared(item) {
          if (!client) {
            alert("Supabase client not ready");
            return;
          }

          const r = await client.storage.from(BUCKET).download(item.path);
          if (r.error) {
            alert("Download failed: " + r.error.message);
            return;
          }

          const text = await r.data.text();
          let parsed;
          try {
            parsed = parseSquabbitCSV(text);
          } catch (err) {
            alert(err?.message || "Failed to parse CSV (Winter League).");
            return;
          }

          const ps = parsed.players || [];
          setPlayers(ps);
          setSelectedPlayer(ps[0]?.name || "");
          setEventName(item.name);
          setCourseTees(parsed.courseTees || []);
          setCourseName(parsed.courseName || "");

          setView("event");
          toast("Event loaded");
        }

        async function fetchSeason(c) {
          c = c || client;
          if (!c) return;

          const r = await c
            .from(STANDINGS_TABLE)
            .select(
              "name,total_points,events,best_event_points,best_hole_points,eclectic_total,best_per_hole"
            );
          if (r.error) {
            setStatusMsg("Error: " + r.error.message);
            return;
          }

          const map = {};
          for (const rec of r.data || []) {
            if (isTeamLike(rec.name)) continue;

            let bph = [];
            if (Array.isArray(rec.best_per_hole)) bph = rec.best_per_hole;
            else if (typeof rec.best_per_hole === "string") {
              try {
                bph = JSON.parse(rec.best_per_hole);
              } catch {}
            }

            map[rec.name] = {
              name: rec.name,
              totalPoints: rec.total_points || 0,
              events: rec.events || 0,
              bestEventPoints: rec.best_event_points ?? 0,
              bestHolePoints: rec.best_hole_points ?? 0,
              eclecticTotal: rec.eclectic_total ?? 0,
              bestPerHole: (bph || []).map((n) => Number(n) || 0)
            };
          }

          setSeason(map);
        }

        function importLocalCSV(text, filename) {
          let parsed;
          try {
            parsed = parseSquabbitCSV(text);
          } catch (err) {
            alert(err?.message || "Failed to parse CSV (Winter League).");
            return;
          }

          const ps = parsed.players || [];
          setPlayers(ps);
          setSelectedPlayer(ps[0]?.name || "");
          setEventName((filename || "").replace(/\.[^.]+$/, ""));
          setCourseTees(parsed.courseTees || []);
          setCourseName(parsed.courseName || "");

          setView("event");
        }

        function compareByCountback(a, b) {
          const pa = a.perHole || [];
          const pb = b.perHole || [];
          const sum = (arr, s, e) =>
            arr.slice(s, e).reduce((x, y) => x + (Number(y) || 0), 0);

          const aB9 = sum(pa, 9, 18),
            bB9 = sum(pb, 9, 18);
          if (aB9 !== bB9) return bB9 - aB9;

          const aL6 = sum(pa, 12, 18),
            bL6 = sum(pb, 12, 18);
          if (aL6 !== bL6) return bL6 - aL6;

          const aL3 = sum(pa, 15, 18),
            bL3 = sum(pb, 15, 18);
          if (aL3 !== bL3) return bL3 - aL3;

          for (let i = 17; i >= 0; i--) {
            const ai = Number(pa[i]) || 0,
              bi = Number(pb[i]) || 0;
            if (ai !== bi) return bi - ai;
          }
          return 0;
        }

        const computed = useMemo(() => {
          if (!players.length) return [];

          const rows = players.map((p, i) => ({
            idx: i,
            name: p.name,
            gender: p.gender,
            teeLabel: p.teeLabel,
            startExact: p.handicap,
            points: p.points,
            back9: p.back9,
            perHole: p.perHole
          }));

          const base = [...rows].sort(
            (a, b) => b.points - a.points || compareByCountback(a, b)
          );

          const groups = [];
          const used = new Set();

          for (const r of base) {
            if (used.has(r.idx)) continue;
            const grpIdxs = base
              .filter((x) => x.points === r.points)
              .map((x) => x.idx);
            grpIdxs.forEach((id) => used.add(id));
            groups.push(grpIdxs);
          }

          const topGroup =
            groups[0]?.map((i) => rows.find((r) => r.idx === i)) || [];
          let best = topGroup.length ? [topGroup[0]] : [];
          for (let k = 1; k < topGroup.length; k++) {
            const cmp = compareByCountback(topGroup[k], best[0]);
            if (cmp > 0) {
              best = [topGroup[k]];
            } else if (cmp === 0) {
              best.push(topGroup[k]);
            }
          }
          const winnerIdxSet = new Set(best.map((r) => r.idx));

          let pos = 1;
          const out = [];

          for (let gi = 0; gi < groups.length; gi++) {
            const g = groups[gi];
            const start = pos;
            const ptsValue = POINTS_TABLE[start - 1] || 0;

            for (const i of g) {
              const r = rows.find((x) => x.idx === i);
              const isWinner = winnerIdxSet.has(i) && gi === 0;

              const hc = computeNewExactHandicap(
                r.startExact,
                r.gender,
                r.points,
                r.back9,
                isWinner
              );

              out.push({
                ...r,
                position: start,
                leaguePoints: ptsValue,
                isWinner,
                nextExact: hc.nextExact,
                nextPlaying: hc.nextPlaying
              });
            }

            pos += g.length;
          }

          return out.sort((a, b) => a.position - b.position);
        }, [players]);

        async function addEventToSeason() {
          if (!computed.length) {
            toast("Load an event first");
            return;
          }
          const next = { ...season };

          for (const r of computed) {
            if (isTeamLike(r.name)) continue;

            const prev = next[r.name] || {
              name: r.name,
              totalPoints: 0,
              events: 0,
              bestPerHole: Array(18).fill(0),
              eclecticTotal: 0,
              bestEventPoints: 0,
              bestHolePoints: 0
            };

            const eventPerHole = (r.perHole || []).map((v) =>
              Math.max(0, Math.min(6, Number(v) || 0))
            );

            const bestPerHole = prev.bestPerHole.map((v, i) =>
              Math.max(v, eventPerHole[i])
            );
            const eclecticTotal = bestPerHole.reduce((s, v) => s + v, 0);
            const bestEvent = Math.max(prev.bestEventPoints || 0, r.points || 0);
            const bestHole = Math.max(
              prev.bestHolePoints || 0,
              Math.max(...eventPerHole)
            );

            next[r.name] = {
              name: r.name,
              totalPoints: (prev.totalPoints || 0) + (r.leaguePoints || 0),
              events: (prev.events || 0) + 1,
              bestEventPoints: bestEvent,
              bestHolePoints: bestHole,
              eclecticTotal,
              bestPerHole
            };
          }

          setSeason(next);

          if (client) {
            const vals = Object.values(next).filter((r) => !isTeamLike(r.name));
            const rows = vals.map((r) => ({
              name: r.name,
              total_points: r.totalPoints,
              events: r.events,
              best_event_points: r.bestEventPoints,
              best_hole_points: r.bestHolePoints,
              eclectic_total: r.eclecticTotal,
              best_per_hole: r.bestPerHole
            }));

            const res = await client
              .from(STANDINGS_TABLE)
              .upsert(rows, { onConflict: "name" });
            if (res.error) toast("Error: " + res.error.message);
            else toast("Event added to season ✓");
          }
        }

        async function removeEventFromSeason() {
          if (!computed.length) {
            toast("Load an event first");
            return;
          }
          if (!window.confirm("Remove this event from the season standings?"))
            return;

          const next = { ...season };
          const oldSeason = season;

          for (const r of computed) {
            const prev = next[r.name];
            if (!prev) continue;

            const newTotal = prev.totalPoints - r.leaguePoints;
            const newEvents = Math.max(0, prev.events - 1);

            if (newTotal <= 0 && newEvents === 0) {
              delete next[r.name];
            } else {
              next[r.name] = { ...prev, totalPoints: newTotal, events: newEvents };
            }
          }

          setSeason(next);
          if (client) {
            const removedNames = Object.keys(oldSeason).filter((k) => !next[k]);
            if (removedNames.length) {
              await client.from(STANDINGS_TABLE).delete().in("name", removedNames);
            }

            const vals = Object.values(next).filter((r) => !isTeamLike(r.name));
            const rows = vals.map((r) => ({
              name: r.name,
              total_points: r.totalPoints,
              events: r.events,
              best_event_points: r.bestEventPoints,
              best_hole_points: r.bestHolePoints,
              eclectic_total: r.eclecticTotal,
              best_per_hole: r.bestPerHole
            }));

            const res = await client
              .from(STANDINGS_TABLE)
              .upsert(rows, { onConflict: "name" });
            if (res.error) toast("Error: " + res.error.message);
            else toast("Event removed from season ✓");
          }
        }

        async function clearSeason() {
          if (!client) {
            toast("No client");
            return;
          }
          if (
            !window.confirm("⚠ This will delete ALL season standings. Continue?")
          )
            return;

          const res = await client.from(STANDINGS_TABLE).delete().neq("name", "");
          if (res.error) toast("Error: " + res.error.message);
          else {
            setSeason({});
            toast("Season cleared");
          }
        }

        function Header({ eventName, statusMsg, courseName }) {
          return (
            <header className="hide-print rounded-2xl p-4 border border-squab-700 bg-squab-600 text-white shadow">
              <div className="flex items-center justify-between gap-2">
                <div>
                  <h1 className="text-xl md:text-2xl font-bold tracking-tight">
                    Wednesday Winter League — Events & Eclectic
                  </h1>
                  <p className="text-xs text-white/90">Supabase: {statusMsg}</p>
                  {courseName && (
                    <p className="text-xs text-white/80 mt-1">
                      Course: {courseName}
                    </p>
                  )}
                </div>
                <span className="hidden sm:inline-flex chip border-white/30 bg-white/10 text-white">
                  {eventName || "Untitled Event"}
                </span>
              </div>
            </header>
          );
        }

        function EventNav({ setView }) {
          return (
            <nav className="flex flex-wrap gap-2 mb-4">
              <button className="chip" onClick={() => setView("event")}>
                Event
              </button>
              <button className="chip" onClick={() => setView("ratings")}>
                Ratings
              </button>
              <button className="chip" onClick={() => setView("holes")}>
                Hole Analysis
              </button>
              <button className="chip" onClick={() => setView("standings")}>
                Standings
              </button>
              <button className="chip" onClick={() => setView("eclectic")}>
                Eclectic
              </button>
              <button className="chip" onClick={() => setView("home")}>
                Home
              </button>
            </nav>
          );
        }

        function Home({
          setView,
          fileInputRef,
          importLocalCSV,
          computed,
          addEventToSeason,
          removeEventFromSeason,
          clearSeason
        }) {
          const canAct = computed.length > 0;
          const [open, setOpen] = useState(true);

          return (
            <section className="rounded-2xl p-3 md:p-4 panel-mint shadow-sm">
              <button
                className="w-full bg-white text-neutral-900 border border-squab-200 rounded-xl px-4 py-3 flex items-center justify-between"
                onClick={() => setOpen((v) => !v)}
              >
                <span className="font-semibold">Menu</span>
                <span
                  className={`transition-transform ${open ? "rotate-180" : ""}`}
                >
                  ▾
                </span>
              </button>

              <div
                className={`overflow-hidden transition-all ${
                  open ? "max-h-[2000px]" : "max-h-0"
                }`}
              >
                <div className="mt-3 grid gap-2">
                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView("past")}
                  >
                    View Past Winter League Events
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView("ratings")}
                  >
                    View Player Ratings
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView("holes")}
                  >
                    Player Hole Analysis
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView("standings")}
                  >
                    Check Season Standings
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() => setView("eclectic")}
                  >
                    Check Eclectic Leaderboard
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-squab-200 bg-white px-3 py-2"
                    onClick={() =>
                      fileInputRef.current && fileInputRef.current.click()
                    }
                  >
                    Import CSV
                  </button>

                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".csv"
                    className="hidden"
                    onChange={async (e) => {
                      const f = e.target.files?.[0];
                      if (!f) return;
                      const text = await f.text();
                      importLocalCSV(text, f.name);
                      e.target.value = "";
                    }}
                  />

                  <button
                    className={`w-full text-left rounded-xl border px-3 py-2 ${
                      canAct
                        ? "border-squab-200 bg-white"
                        : "border-neutral-200 bg-neutral-50 text-neutral-400 cursor-not-allowed"
                    }`}
                    onClick={addEventToSeason}
                    disabled={!canAct}
                  >
                    Add Event → Season
                  </button>

                  <button
                    className={`w-full text-left rounded-xl border px-3 py-2 ${
                      canAct
                        ? "border-amber-300 bg-amber-50 text-amber-800"
                        : "border-neutral-200 bg-neutral-50 text-neutral-400 cursor-not-allowed"
                    }`}
                    onClick={removeEventFromSeason}
                    disabled={!canAct}
                  >
                    Remove Event ← Season
                  </button>

                  <button
                    className="w-full text-left rounded-xl border border-red-300 bg-red-50 px-3 py-2 text-red-700"
                    onClick={clearSeason}
                  >
                    Delete Entire Season
                  </button>
                </div>
              </div>
            </section>
          );
        }

        function PastEvents({ sharedGroups, loadShared, setView }) {
          return (
            <section className="rounded-2xl p-3 md:p-4 bg-white border border-squab-200 shadow-sm">
              <div className="flex items-center justify-between mb-2">
                <h2 className="text-lg font-semibold text-squab-900">
                  Past Winter League Events
                </h2>
                <button
                  className="btn border border-squab-200"
                  onClick={() => setView("home")}
                >
                  Back
                </button>
              </div>

              {sharedGroups.length === 0 && (
                <div className="text-sm text-neutral-600 p-2">
                  No shared CSVs yet.
                </div>
              )}

              {sharedGroups.map((group) => (
                <div key={group.year} className="mb-3">
                  <div className="text-xs text-neutral-600 mb-1">
                    {group.year}
                  </div>
                  <select
                    className="w-full rounded-xl border border-squab-200 px-3 py-2 bg-white"
                    onChange={async (e) => {
                      const idx = e.target.value;
                      if (idx === "") return;
                      const item = group.events[Number(idx)];
                      await loadShared(item);
                    }}
                  >
                    <option value="">Select an event…</option>
                    {group.events.map((item, i) => (
                      <option key={item.path} value={i}>
                        {item.name}
                      </option>
                    ))}
                  </select>
                </div>
              ))}
            </section>
          );
        }

        function EventScreen({ computed, setView }) {
          return (
            <section className="rounded-2xl p-4 md:p-6 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">
                Event Leaderboard
              </h2>

              <div className="overflow-auto">
                <table className="min-w-full text-sm">
                  <thead className="sticky top-0 bg-white z-10">
                    <tr className="border-b border-squab-200 text-left">
                      <th>#</th>
                      <th>Name</th>
                      <th>Tee</th>
                      <th>Handicap</th>
                      <th>Stableford</th>
                      <th>Back9</th>
                      <th>Pts</th>
                      <th>New Hcap</th>
                    </tr>
                  </thead>

                  <tbody className="[&_tr:nth-child(even)]:bg-squab-50">
                    {computed.length === 0 && (
                      <tr>
                        <td colSpan="8" className="py-3 text-neutral-600">
                          Load an event to see results.
                        </td>
                      </tr>
                    )}

                    {computed.map((r, i) => (
                      <tr key={i} className="border-b border-squab-200">
                        <td>{r.position}</td>
                        <td className="whitespace-nowrap">{r.name}</td>
                        <td className="whitespace-nowrap text-xs">
                          {r.teeLabel || "—"}
                        </td>
                        <td>{Math.round(r.startExact)}</td>
                        <td>{r.points}</td>
                        <td>{r.back9}</td>
                        <td>{r.leaguePoints}</td>
                        <td>{r.nextPlaying}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        // --- UPDATED Ratings: gross-based strokes vs par ---
        function Ratings({ computed, courseTees, setView }) {
          const ratingLabel = (avg) =>
            avg <= -0.75
              ? "On Fire"
              : avg <= -0.25
              ? "Under Par"
              : avg <= 0.5
              ? "Solid"
              : avg <= 1
              ? "Needs Work"
              : "Struggle";

          const badgeClass = (avg) =>
            avg <= -0.25
              ? "bg-emerald-100 text-emerald-800"
              : avg <= 0.5
              ? "bg-emerald-50 text-emerald-700"
              : avg <= 1
              ? "bg-amber-100 text-amber-800"
              : "bg-red-100 text-red-800";

          const fmt = (v) => (v > 0 ? "+" : "") + v.toFixed(1);

          const ratings = useMemo(() => {
            return computed
              .map((r) => {
                const tee = chooseTeeForPlayer(r, courseTees);
                if (!tee) {
                  return {
                    name: r.name,
                    p3: 0,
                    p4: 0,
                    p5: 0,
                    total: 0
                  };
                }

                const pars = tee.pars || [];
                const sis = tee.si || [];
                const perHole = r.perHole || Array(18).fill(0);
                const hcap = playingHandicapFromExact(r.startExact);

                const par3 = [];
                const par4 = [];
                const par5 = [];

                for (let i = 0; i < 18; i++) {
                  const par = pars[i];
                  const pts = perHole[i] || 0;
                  const netRel = netVsParFromPoints(pts); // net vs par
                  const shots = strokesReceivedForHole(sis[i], hcap);
                  const grossRel = netRel + shots; // gross vs par

                  if (par === 3) par3.push(grossRel);
                  if (par === 4) par4.push(grossRel);
                  if (par === 5) par5.push(grossRel);
                }

                const avg = (arr) =>
                  arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;

                const p3 = avg(par3);
                const p4 = avg(par4);
                const p5 = avg(par5);

                return {
                  name: r.name,
                  p3: to1(p3),
                  p4: to1(p4),
                  p5: to1(p5),
                  total: to1(p3 + p4 + p5)
                };
              })
              // lower total (strokes over par) is better
              .sort((a, b) => a.total - b.total);
          }, [computed, courseTees]);

          return (
            <section className="rounded-2xl p-3 md:p-5 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">
                Player Ratings (Gross Strokes vs Par)
              </h2>

              <div className="overflow-auto">
                <table className="min-w-full text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 text-left">
                      <th>Name</th>
                      <th>Par-3 Avg (Δ Strokes)</th>
                      <th>Rating</th>
                      <th>Par-4 Avg (Δ Strokes)</th>
                      <th>Rating</th>
                      <th>Par-5 Avg (Δ Strokes)</th>
                      <th>Rating</th>
                    </tr>
                  </thead>

                  <tbody>
                    {ratings.map((r) => (
                      <tr key={r.name} className="border-b border-squab-200">
                        <td className="font-medium">{r.name}</td>

                        <td>{fmt(r.p3)}</td>
                        <td>
                          <span
                            className={`px-2 py-0.5 rounded-lg text-xs ${badgeClass(
                              r.p3
                            )}`}
                          >
                            {ratingLabel(r.p3)}
                          </span>
                        </td>

                        <td>{fmt(r.p4)}</td>
                        <td>
                          <span
                            className={`px-2 py-0.5 rounded-lg text-xs ${badgeClass(
                              r.p4
                            )}`}
                          >
                            {ratingLabel(r.p4)}
                          </span>
                        </td>

                        <td>{fmt(r.p5)}</td>
                        <td>
                          <span
                            className={`px-2 py-0.5 rounded-lg text-xs ${badgeClass(
                              r.p5
                            )}`}
                          >
                            {ratingLabel(r.p5)}
                          </span>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        function Standings({ season, setView }) {
          const list = Object.values(season)
            .filter((r) => !isTeamLike(r.name))
            .sort(
              (a, b) =>
                b.totalPoints - a.totalPoints || a.name.localeCompare(b.name)
            );

          return (
            <section className="rounded-2xl p-3 md:p-5 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">
                Season Standings
              </h2>

              <div className="overflow-auto">
                <table className="min-w-full text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 text-left">
                      <th>Rank</th>
                      <th>Name</th>
                      <th>Events</th>
                      <th>Total</th>
                      <th>Best Event</th>
                      <th>Best Hole</th>
                      <th>Eclectic</th>
                    </tr>
                  </thead>

                  <tbody>
                    {list.map((r, i) => (
                      <tr key={r.name} className="border-b border-squab-200">
                        <td>{i + 1}</td>
                        <td>{r.name}</td>
                        <td>{r.events}</td>
                        <td>{r.totalPoints}</td>
                        <td>{r.bestEventPoints}</td>
                        <td>{r.bestHolePoints}</td>
                        <td>{r.eclecticTotal}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        function Eclectic({ season, setView }) {
          const list = Object.values(season)
            .filter((r) => !isTeamLike(r.name))
            .sort((a, b) => (b.eclecticTotal || 0) - (a.eclecticTotal || 0));

          return (
            <section className="rounded-2xl p-3 md:p-5 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-3">
                Eclectic Leaderboard
              </h2>

              <div className="overflow-auto">
                <table className="min-w-full text-xs md:text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 text-left">
                      <th>Rank</th>
                      <th>Name</th>
                      <th>Eclectic Total</th>
                      {Array.from({ length: 18 }, (_, i) => (
                        <th key={i}>H{i + 1}</th>
                      ))}
                    </tr>
                  </thead>

                  <tbody>
                    {list.map((r, i) => (
                      <tr key={r.name} className="border-b border-squab-200">
                        <td>{i + 1}</td>
                        <td>{r.name}</td>
                        <td>{r.eclecticTotal}</td>
                        {(r.bestPerHole || Array(18).fill(0)).map((v, ix) => (
                          <td key={ix}>{v}</td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        // --- UPDATED HoleAnalysis: gross-based strokes vs par & strokes gained vs field ---
        function HoleAnalysis({
          computed,
          selectedPlayer,
          setSelectedPlayer,
          courseTees,
          setView
        }) {
          if (!computed.length) {
            return (
              <section className="rounded-2xl p-4 bg-white border border-squab-200 shadow-sm">
                <EventNav setView={setView} />
                <p className="text-neutral-600">
                  Load an event to see hole analysis.
                </p>
              </section>
            );
          }

          const playerNames = computed.map((p) => p.name);
          const player =
            computed.find((p) => p.name === selectedPlayer) || computed[0];

          const tee = chooseTeeForPlayer(player, courseTees);
          if (!tee) {
            return (
              <section className="rounded-2xl p-4 bg-white border border-squab-200 shadow-sm">
                <EventNav setView={setView} />
                <p className="text-neutral-600">
                  No tee layout found in CourseLayout for this player. Check the CSV
                  tee names and player tee labels.
                </p>
              </section>
            );
          }

          const perHole = player.perHole || Array(18).fill(0);
          const pars = tee.pars;
          const yards = tee.yards;
          const siArr = tee.si;
          const playingHcap = playingHandicapFromExact(player.startExact);

          // Player gross vs par per hole
          const grossRelPlayer = perHole.map((pts, i) => {
            const netRel = netVsParFromPoints(pts);
            const shots = strokesReceivedForHole(siArr[i], playingHcap);
            return netRel + shots;
          });

          // Field average gross vs par per hole
          const fieldGrossRel = Array(18).fill(0);
          for (let h = 0; h < 18; h++) {
            const vals = computed.map((p) => {
              const ph = p.perHole || Array(18).fill(0);
              const pts = ph[h] || 0;
              const teeP = chooseTeeForPlayer(p, courseTees) || tee;
              const siP = (teeP.si || [])[h] || siArr[h];
              const hcapP = playingHandicapFromExact(p.startExact);
              const netRel = netVsParFromPoints(pts);
              const shots = strokesReceivedForHole(siP, hcapP);
              return netRel + shots;
            });
            fieldGrossRel[h] = vals.reduce((a, b) => a + b, 0) / vals.length;
          }

          // Strokes gained vs field (gross)
          const gains = grossRelPlayer.map((gp, i) => fieldGrossRel[i] - gp);
          const totalGain = gains.reduce((a, b) => a + b, 0);

          const bestHole = gains
            .map((g, i) => ({ hole: i + 1, g }))
            .sort((a, b) => b.g - a.g)[0];

          const worstHole = gains
            .map((g, i) => ({ hole: i + 1, g }))
            .sort((a, b) => a.g - b.g)[0];

          // Par-type averages (gross vs par)
          const par3 = [],
            par4 = [],
            par5 = [];
          for (let i = 0; i < 18; i++) {
            if (pars[i] === 3) par3.push(grossRelPlayer[i]);
            if (pars[i] === 4) par4.push(grossRelPlayer[i]);
            if (pars[i] === 5) par5.push(grossRelPlayer[i]);
          }
          const avgP3 = par3.reduce((a, b) => a + b, 0) / (par3.length || 1);
          const avgP4 = par4.reduce((a, b) => a + b, 0) / (par4.length || 1);
          const avgP5 = par5.reduce((a, b) => a + b, 0) / (par5.length || 1);

          const holeType = (h) => {
            const par = pars[h];
            const yd = yards[h];

            if (!par) return "Unknown";

            if (par === 3) return "Par 3";
            if (par === 4) return yd >= 400 ? "Long Par 4" : "Par 4";
            if (par === 5) return yd >= 520 ? "Long Par 5" : "Par 5";
            return "Unknown";
          };

          const fmtSigned = (v) => (v > 0 ? "+" : "") + to1(v);

          return (
            <section className="rounded-2xl p-4 md:p-6 bg-white border border-squab-200 shadow-sm">
              <EventNav setView={setView} />

              <h2 className="text-lg font-semibold text-squab-900 mb-1">
                Player Hole Analysis (Gross-based)
              </h2>
              <p className="text-xs text-neutral-600 mb-3">
                Tee for this player:{" "}
                <span className="font-semibold">
                  {player.teeLabel || tee.teeName || "Unknown"}
                </span>
                {" · "}
                Playing handicap (approx):{" "}
                <span className="font-semibold">{playingHcap}</span>
              </p>

              <div className="mb-4">
                <label className="block text-sm font-medium mb-1">
                  Select Player
                </label>
                <select
                  className="w-full max-w-xs rounded-xl border border-squab-200 px-3 py-2 bg-white"
                  value={selectedPlayer}
                  onChange={(e) => setSelectedPlayer(e.target.value)}
                >
                  {playerNames.map((name) => (
                    <option key={name}>{name}</option>
                  ))}
                </select>
              </div>

              <div className="grid md:grid-cols-3 gap-4 mb-5">
                <div className="p-3 border border-squab-200 rounded-xl bg-squab-50">
                  <div className="text-xs text-neutral-600">
                    Total Strokes Gained vs Field (gross)
                  </div>
                  <div className="text-xl font-bold">{fmtSigned(totalGain)}</div>
                </div>

                <div className="p-3 border border-squab-200 rounded-xl bg-squab-50">
                  <div className="text-xs text-neutral-600">Best Hole</div>
                  <div className="text-sm md:text-xl font-bold">
                    Hole {bestHole.hole} ({fmtSigned(bestHole.g)} strokes vs field)
                  </div>
                </div>

                <div className="p-3 border border-squab-200 rounded-xl bg-squab-50">
                  <div className="text-xs text-neutral-600">Worst Hole</div>
                  <div className="text-sm md:text-xl font-bold">
                    Hole {worstHole.hole} ({fmtSigned(worstHole.g)} strokes vs
                    field)
                  </div>
                </div>
              </div>

              <div className="grid md:grid-cols-3 gap-4 mb-6">
                <div className="p-3 bg-white border border-squab-200 rounded-xl">
                  <div className="text-xs text-neutral-600">
                    Avg Par-3 vs Par (gross)
                  </div>
                  <div className="text-xl font-semibold">
                    {fmtSigned(avgP3)}
                  </div>
                </div>
                <div className="p-3 bg-white border border-squab-200 rounded-xl">
                  <div className="text-xs text-neutral-600">
                    Avg Par-4 vs Par (gross)
                  </div>
                  <div className="text-xl font-semibold">
                    {fmtSigned(avgP4)}
                  </div>
                </div>
                <div className="p-3 bg-white border border-squab-200 rounded-xl">
                  <div className="text-xs text-neutral-600">
                    Avg Par-5 vs Par (gross)
                  </div>
                  <div className="text-xl font-semibold">
                    {fmtSigned(avgP5)}
                  </div>
                </div>
              </div>

              <div className="overflow-auto">
                <table className="min-w-full text-xs md:text-sm">
                  <thead>
                    <tr className="border-b border-squab-200 bg-squab-50 text-left">
                      <th>Hole</th>
                      <th>Par</th>
                      <th>Yards</th>
                      <th>SI</th>
                      <th>Pts (Stableford)</th>
                      <th>Gross vs Par (strokes)</th>
                      <th>Field Avg (gross)</th>
                      <th>Gain (strokes)</th>
                      <th>Type</th>
                    </tr>
                  </thead>

                  <tbody>
                    {perHole.map((pts, i) => (
                      <tr key={i} className="border-b">
                        <td>{i + 1}</td>
                        <td>{pars[i]}</td>
                        <td>{yards[i] > 0 ? yards[i] : "—"}</td>
                        <td>{siArr[i] > 0 ? siArr[i] : "—"}</td>
                        <td className="font-semibold">{pts}</td>
                        <td>{fmtSigned(grossRelPlayer[i])}</td>
                        <td>{fmtSigned(fieldGrossRel[i])}</td>
                        <td
                          className={
                            gains[i] >= 0
                              ? "text-emerald-600 font-semibold"
                              : "text-red-600 font-semibold"
                          }
                        >
                          {fmtSigned(gains[i])}
                        </td>
                        <td>{holeType(i)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          );
        }

        return (
          <div className="min-h-screen p-4 sm:p-6">
            <div className="max-w-5xl mx-auto space-y-4">
              <Header
                eventName={eventName}
                statusMsg={statusMsg}
                courseName={courseName}
              />

              {view === "home" && (
                <Home
                  setView={setView}
                  fileInputRef={fileInputRef}
                  importLocalCSV={importLocalCSV}
                  computed={computed}
                  addEventToSeason={addEventToSeason}
                  removeEventFromSeason={removeEventFromSeason}
                  clearSeason={clearSeason}
                />
              )}

              {view === "past" && (
                <PastEvents
                  sharedGroups={sharedGroups}
                  loadShared={loadShared}
                  setView={setView}
                />
              )}

              {view === "event" && (
                <EventScreen computed={computed} setView={setView} />
              )}

              {view === "ratings" && (
                <Ratings
                  computed={computed}
                  courseTees={courseTees}
                  setView={setView}
                />
              )}

              {view === "holes" && (
                <HoleAnalysis
                  computed={computed}
                  selectedPlayer={selectedPlayer}
                  setSelectedPlayer={setSelectedPlayer}
                  courseTees={courseTees}
                  setView={setView}
                />
              )}

              {view === "standings" && (
                <Standings season={season} setView={setView} />
              )}

              {view === "eclectic" && (
                <Eclectic season={season} setView={setView} />
              )}
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
